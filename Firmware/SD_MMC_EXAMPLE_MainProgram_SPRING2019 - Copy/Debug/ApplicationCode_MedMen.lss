
ApplicationCode_MedMen.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000022c0  0000b000  0000b000  0000b000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0000d2c0  0000d2c0  0000d2c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000074  20000000  0000d2c8  00010000  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          00000530  20000074  0000d33c  00010074  2**2
                  ALLOC
  4 .stack        00002004  200005a4  0000d86c  00010074  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  00010074  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  0001009c  2**0
                  CONTENTS, READONLY
  7 .debug_info   00034467  00000000  00000000  000100f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00004829  00000000  00000000  0004455c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00007b61  00000000  00000000  00048d85  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000006d0  00000000  00000000  000508e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000a70  00000000  00000000  00050fb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00009717  00000000  00000000  00051a26  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000f258  00000000  00000000  0005b13d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00091187  00000000  00000000  0006a395  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000127c  00000000  00000000  000fb51c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000b000 <exception_table>:
    b000:	a8 25 00 20 39 cb 00 00 35 cb 00 00 35 cb 00 00     .%. 9...5...5...
	...
    b02c:	35 cb 00 00 00 00 00 00 00 00 00 00 35 cb 00 00     5...........5...
    b03c:	35 cb 00 00 35 cb 00 00 35 cb 00 00 35 cb 00 00     5...5...5...5...
    b04c:	35 cb 00 00 35 cb 00 00 35 cb 00 00 35 cb 00 00     5...5...5...5...
    b05c:	35 cb 00 00 35 cb 00 00 c1 b9 00 00 d1 b9 00 00     5...5...........
    b06c:	e1 b9 00 00 f1 b9 00 00 01 ba 00 00 11 ba 00 00     ................
    b07c:	35 cb 00 00 35 cb 00 00 35 cb 00 00 35 cb 00 00     5...5...5...5...
    b08c:	35 cb 00 00 35 cb 00 00 00 00 00 00 00 00 00 00     5...5...........
    b09c:	35 cb 00 00 35 cb 00 00 35 cb 00 00 35 cb 00 00     5...5...5...5...
    b0ac:	35 cb 00 00 00 00 00 00                             5.......

0000b0b4 <__do_global_dtors_aux>:
    b0b4:	b510      	push	{r4, lr}
    b0b6:	4c06      	ldr	r4, [pc, #24]	; (b0d0 <__do_global_dtors_aux+0x1c>)
    b0b8:	7823      	ldrb	r3, [r4, #0]
    b0ba:	2b00      	cmp	r3, #0
    b0bc:	d107      	bne.n	b0ce <__do_global_dtors_aux+0x1a>
    b0be:	4b05      	ldr	r3, [pc, #20]	; (b0d4 <__do_global_dtors_aux+0x20>)
    b0c0:	2b00      	cmp	r3, #0
    b0c2:	d002      	beq.n	b0ca <__do_global_dtors_aux+0x16>
    b0c4:	4804      	ldr	r0, [pc, #16]	; (b0d8 <__do_global_dtors_aux+0x24>)
    b0c6:	e000      	b.n	b0ca <__do_global_dtors_aux+0x16>
    b0c8:	bf00      	nop
    b0ca:	2301      	movs	r3, #1
    b0cc:	7023      	strb	r3, [r4, #0]
    b0ce:	bd10      	pop	{r4, pc}
    b0d0:	20000074 	.word	0x20000074
    b0d4:	00000000 	.word	0x00000000
    b0d8:	0000d2c8 	.word	0x0000d2c8

0000b0dc <frame_dummy>:
    b0dc:	4b08      	ldr	r3, [pc, #32]	; (b100 <frame_dummy+0x24>)
    b0de:	b510      	push	{r4, lr}
    b0e0:	2b00      	cmp	r3, #0
    b0e2:	d003      	beq.n	b0ec <frame_dummy+0x10>
    b0e4:	4907      	ldr	r1, [pc, #28]	; (b104 <frame_dummy+0x28>)
    b0e6:	4808      	ldr	r0, [pc, #32]	; (b108 <frame_dummy+0x2c>)
    b0e8:	e000      	b.n	b0ec <frame_dummy+0x10>
    b0ea:	bf00      	nop
    b0ec:	4807      	ldr	r0, [pc, #28]	; (b10c <frame_dummy+0x30>)
    b0ee:	6803      	ldr	r3, [r0, #0]
    b0f0:	2b00      	cmp	r3, #0
    b0f2:	d100      	bne.n	b0f6 <frame_dummy+0x1a>
    b0f4:	bd10      	pop	{r4, pc}
    b0f6:	4b06      	ldr	r3, [pc, #24]	; (b110 <frame_dummy+0x34>)
    b0f8:	2b00      	cmp	r3, #0
    b0fa:	d0fb      	beq.n	b0f4 <frame_dummy+0x18>
    b0fc:	4798      	blx	r3
    b0fe:	e7f9      	b.n	b0f4 <frame_dummy+0x18>
    b100:	00000000 	.word	0x00000000
    b104:	20000078 	.word	0x20000078
    b108:	0000d2c8 	.word	0x0000d2c8
    b10c:	0000d2c8 	.word	0x0000d2c8
    b110:	00000000 	.word	0x00000000

0000b114 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
    b114:	b5f0      	push	{r4, r5, r6, r7, lr}
    b116:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    b118:	ac01      	add	r4, sp, #4
    b11a:	2501      	movs	r5, #1
    b11c:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
    b11e:	2700      	movs	r7, #0
    b120:	70a7      	strb	r7, [r4, #2]
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    b122:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
    b124:	0021      	movs	r1, r4
    b126:	2017      	movs	r0, #23
    b128:	4e06      	ldr	r6, [pc, #24]	; (b144 <system_board_init+0x30>)
    b12a:	47b0      	blx	r6
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    b12c:	2280      	movs	r2, #128	; 0x80
    b12e:	0412      	lsls	r2, r2, #16
    b130:	4b05      	ldr	r3, [pc, #20]	; (b148 <system_board_init+0x34>)
    b132:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    b134:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    b136:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
    b138:	0021      	movs	r1, r4
    b13a:	2037      	movs	r0, #55	; 0x37
    b13c:	47b0      	blx	r6
}
    b13e:	b003      	add	sp, #12
    b140:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b142:	46c0      	nop			; (mov r8, r8)
    b144:	0000b5b9 	.word	0x0000b5b9
    b148:	41004400 	.word	0x41004400

0000b14c <advance_pointer>:
 };

 #pragma mark - Private Functions -

 static void advance_pointer(cbuf_handle_t cbuf)
 {
    b14c:	b510      	push	{r4, lr}
    b14e:	0004      	movs	r4, r0
	 //assert(cbuf);

	 if(cbuf->full)
    b150:	7c03      	ldrb	r3, [r0, #16]
    b152:	2b00      	cmp	r3, #0
    b154:	d005      	beq.n	b162 <advance_pointer+0x16>
	 {
		 cbuf->tail = (cbuf->tail + 1) % cbuf->max;
    b156:	6883      	ldr	r3, [r0, #8]
    b158:	1c58      	adds	r0, r3, #1
    b15a:	68e1      	ldr	r1, [r4, #12]
    b15c:	4b07      	ldr	r3, [pc, #28]	; (b17c <advance_pointer+0x30>)
    b15e:	4798      	blx	r3
    b160:	60a1      	str	r1, [r4, #8]
	 }

	 cbuf->head = (cbuf->head + 1) % cbuf->max;
    b162:	6863      	ldr	r3, [r4, #4]
    b164:	1c58      	adds	r0, r3, #1
    b166:	68e1      	ldr	r1, [r4, #12]
    b168:	4b04      	ldr	r3, [pc, #16]	; (b17c <advance_pointer+0x30>)
    b16a:	4798      	blx	r3
    b16c:	6061      	str	r1, [r4, #4]

	 // We mark full because we will advance tail on the next time around
	 cbuf->full = (cbuf->head == cbuf->tail);
    b16e:	68a3      	ldr	r3, [r4, #8]
    b170:	1a59      	subs	r1, r3, r1
    b172:	424a      	negs	r2, r1
    b174:	414a      	adcs	r2, r1
    b176:	7422      	strb	r2, [r4, #16]
 }
    b178:	bd10      	pop	{r4, pc}
    b17a:	46c0      	nop			; (mov r8, r8)
    b17c:	0000ce45 	.word	0x0000ce45

0000b180 <circular_buf_init>:
 }

 #pragma mark - APIs -

 cbuf_handle_t circular_buf_init(uint8_t* buffer, size_t size)
 {
    b180:	b570      	push	{r4, r5, r6, lr}
    b182:	0005      	movs	r5, r0
    b184:	000c      	movs	r4, r1
	// assert(buffer && size);

	 cbuf_handle_t cbuf = malloc(sizeof(circular_buf_t));
    b186:	2014      	movs	r0, #20
    b188:	4b04      	ldr	r3, [pc, #16]	; (b19c <circular_buf_init+0x1c>)
    b18a:	4798      	blx	r3
	 //assert(cbuf);

	 cbuf->buffer = buffer;
    b18c:	6005      	str	r5, [r0, #0]
	 cbuf->max = size;
    b18e:	60c4      	str	r4, [r0, #12]

 void circular_buf_reset(cbuf_handle_t cbuf)
 {
	// assert(cbuf);

	 cbuf->head = 0;
    b190:	2300      	movs	r3, #0
    b192:	6043      	str	r3, [r0, #4]
	 cbuf->tail = 0;
    b194:	6083      	str	r3, [r0, #8]
	 cbuf->full = false;
    b196:	7403      	strb	r3, [r0, #16]
 }
    b198:	bd70      	pop	{r4, r5, r6, pc}
    b19a:	46c0      	nop			; (mov r8, r8)
    b19c:	0000d101 	.word	0x0000d101

0000b1a0 <circular_buf_put>:

	 return cbuf->max;
 }

 void circular_buf_put(cbuf_handle_t cbuf, uint8_t data)
 {
    b1a0:	b510      	push	{r4, lr}
	 //assert(cbuf && cbuf->buffer);

	 cbuf->buffer[cbuf->head] = data;
    b1a2:	6803      	ldr	r3, [r0, #0]
    b1a4:	6842      	ldr	r2, [r0, #4]
    b1a6:	5499      	strb	r1, [r3, r2]

	 advance_pointer(cbuf);
    b1a8:	4b01      	ldr	r3, [pc, #4]	; (b1b0 <circular_buf_put+0x10>)
    b1aa:	4798      	blx	r3
 }
    b1ac:	bd10      	pop	{r4, pc}
    b1ae:	46c0      	nop			; (mov r8, r8)
    b1b0:	0000b14d 	.word	0x0000b14d

0000b1b4 <circular_buf_empty>:

 bool circular_buf_empty(cbuf_handle_t cbuf)
 {
	 //assert(cbuf);

	 return (!cbuf->full && (cbuf->head == cbuf->tail));
    b1b4:	7c02      	ldrb	r2, [r0, #16]
    b1b6:	2300      	movs	r3, #0
    b1b8:	2a00      	cmp	r2, #0
    b1ba:	d105      	bne.n	b1c8 <circular_buf_empty+0x14>
    b1bc:	6843      	ldr	r3, [r0, #4]
    b1be:	6880      	ldr	r0, [r0, #8]
    b1c0:	1a1b      	subs	r3, r3, r0
    b1c2:	4258      	negs	r0, r3
    b1c4:	4143      	adcs	r3, r0
    b1c6:	b2db      	uxtb	r3, r3
    b1c8:	0018      	movs	r0, r3
 }
    b1ca:	4770      	bx	lr

0000b1cc <circular_buf_get>:
 {
    b1cc:	b570      	push	{r4, r5, r6, lr}
    b1ce:	0004      	movs	r4, r0
    b1d0:	000d      	movs	r5, r1
	 if(!circular_buf_empty(cbuf))
    b1d2:	4b0a      	ldr	r3, [pc, #40]	; (b1fc <circular_buf_get+0x30>)
    b1d4:	4798      	blx	r3
    b1d6:	2800      	cmp	r0, #0
    b1d8:	d10d      	bne.n	b1f6 <circular_buf_get+0x2a>
		 *data = cbuf->buffer[cbuf->tail];
    b1da:	6823      	ldr	r3, [r4, #0]
    b1dc:	68a2      	ldr	r2, [r4, #8]
    b1de:	5c9b      	ldrb	r3, [r3, r2]
    b1e0:	702b      	strb	r3, [r5, #0]
	 cbuf->full = false;
    b1e2:	2300      	movs	r3, #0
    b1e4:	7423      	strb	r3, [r4, #16]
	 cbuf->tail = (cbuf->tail + 1) % cbuf->max;
    b1e6:	68a3      	ldr	r3, [r4, #8]
    b1e8:	1c58      	adds	r0, r3, #1
    b1ea:	68e1      	ldr	r1, [r4, #12]
    b1ec:	4b04      	ldr	r3, [pc, #16]	; (b200 <circular_buf_get+0x34>)
    b1ee:	4798      	blx	r3
    b1f0:	60a1      	str	r1, [r4, #8]
		 r = 0;
    b1f2:	2000      	movs	r0, #0
 }
    b1f4:	bd70      	pop	{r4, r5, r6, pc}
	 int r = -1;
    b1f6:	2001      	movs	r0, #1
    b1f8:	4240      	negs	r0, r0
	 return r;
    b1fa:	e7fb      	b.n	b1f4 <circular_buf_get+0x28>
    b1fc:	0000b1b5 	.word	0x0000b1b5
    b200:	0000ce45 	.word	0x0000ce45

0000b204 <usart_write_callback>:
* @fn			void usart_write_callback(struct usart_module *const usart_module)
* @brief		Callback called when the system finishes sending all the bytes requested from a UART read job
* @note
*****************************************************************************/
void usart_write_callback(struct usart_module *const usart_module)
{
    b204:	b510      	push	{r4, lr}
	if(circular_buf_get(cbufTx, (uint8_t*) &latestTx) != -1) //Only continue if there are more characters to send
    b206:	4b06      	ldr	r3, [pc, #24]	; (b220 <usart_write_callback+0x1c>)
    b208:	6818      	ldr	r0, [r3, #0]
    b20a:	4906      	ldr	r1, [pc, #24]	; (b224 <usart_write_callback+0x20>)
    b20c:	4b06      	ldr	r3, [pc, #24]	; (b228 <usart_write_callback+0x24>)
    b20e:	4798      	blx	r3
    b210:	1c43      	adds	r3, r0, #1
    b212:	d004      	beq.n	b21e <usart_write_callback+0x1a>
	{
		usart_write_buffer_job(&usart_instance, (uint8_t*) &latestTx, 1);
    b214:	2201      	movs	r2, #1
    b216:	4903      	ldr	r1, [pc, #12]	; (b224 <usart_write_callback+0x20>)
    b218:	4804      	ldr	r0, [pc, #16]	; (b22c <usart_write_callback+0x28>)
    b21a:	4b05      	ldr	r3, [pc, #20]	; (b230 <usart_write_callback+0x2c>)
    b21c:	4798      	blx	r3
	}
	
}
    b21e:	bd10      	pop	{r4, pc}
    b220:	20000580 	.word	0x20000580
    b224:	2000057c 	.word	0x2000057c
    b228:	0000b1cd 	.word	0x0000b1cd
    b22c:	20000140 	.word	0x20000140
    b230:	0000c1b1 	.word	0x0000c1b1

0000b234 <InitializeSerialConsole>:
{
    b234:	b530      	push	{r4, r5, lr}
    b236:	b091      	sub	sp, #68	; 0x44
	cbufRx = circular_buf_init((uint8_t*)rxCharacterBuffer, RX_BUFFER_SIZE);
    b238:	2580      	movs	r5, #128	; 0x80
    b23a:	00ad      	lsls	r5, r5, #2
    b23c:	0029      	movs	r1, r5
    b23e:	4836      	ldr	r0, [pc, #216]	; (b318 <InitializeSerialConsole+0xe4>)
    b240:	4c36      	ldr	r4, [pc, #216]	; (b31c <InitializeSerialConsole+0xe8>)
    b242:	47a0      	blx	r4
    b244:	4b36      	ldr	r3, [pc, #216]	; (b320 <InitializeSerialConsole+0xec>)
    b246:	6018      	str	r0, [r3, #0]
	cbufTx = circular_buf_init((uint8_t*)txCharacterBuffer, RX_BUFFER_SIZE);
    b248:	0029      	movs	r1, r5
    b24a:	4836      	ldr	r0, [pc, #216]	; (b324 <InitializeSerialConsole+0xf0>)
    b24c:	47a0      	blx	r4
    b24e:	4b36      	ldr	r3, [pc, #216]	; (b328 <InitializeSerialConsole+0xf4>)
    b250:	6018      	str	r0, [r3, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    b252:	2380      	movs	r3, #128	; 0x80
    b254:	05db      	lsls	r3, r3, #23
    b256:	9300      	str	r3, [sp, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    b258:	2300      	movs	r3, #0
    b25a:	9301      	str	r3, [sp, #4]
	config->parity           = USART_PARITY_NONE;
    b25c:	22ff      	movs	r2, #255	; 0xff
    b25e:	4669      	mov	r1, sp
    b260:	810a      	strh	r2, [r1, #8]
	config->stopbits         = USART_STOPBITS_1;
    b262:	2200      	movs	r2, #0
    b264:	728b      	strb	r3, [r1, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    b266:	72cb      	strb	r3, [r1, #11]
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    b268:	2101      	movs	r1, #1
    b26a:	2024      	movs	r0, #36	; 0x24
    b26c:	466c      	mov	r4, sp
    b26e:	5421      	strb	r1, [r4, r0]
	config->transmitter_enable = true;
    b270:	3001      	adds	r0, #1
    b272:	5421      	strb	r1, [r4, r0]
	config->clock_polarity_inverted = false;
    b274:	3125      	adds	r1, #37	; 0x25
    b276:	5463      	strb	r3, [r4, r1]
	config->use_external_clock = false;
    b278:	3101      	adds	r1, #1
    b27a:	5463      	strb	r3, [r4, r1]
	config->ext_clock_freq   = 0;
    b27c:	930a      	str	r3, [sp, #40]	; 0x28
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    b27e:	3105      	adds	r1, #5
    b280:	5463      	strb	r3, [r4, r1]
	config->generator_source = GCLK_GENERATOR_0;
    b282:	3101      	adds	r1, #1
    b284:	5463      	strb	r3, [r4, r1]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    b286:	9305      	str	r3, [sp, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    b288:	8223      	strh	r3, [r4, #16]
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    b28a:	76e3      	strb	r3, [r4, #27]
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    b28c:	7622      	strb	r2, [r4, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    b28e:	7722      	strb	r2, [r4, #28]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    b290:	7662      	strb	r2, [r4, #25]
	config->receive_pulse_length                    = 19;
    b292:	2313      	movs	r3, #19
    b294:	76a3      	strb	r3, [r4, #26]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    b296:	7762      	strb	r2, [r4, #29]
	config_usart.baudrate    = 115200;
    b298:	23e1      	movs	r3, #225	; 0xe1
    b29a:	025b      	lsls	r3, r3, #9
    b29c:	9308      	str	r3, [sp, #32]
	config_usart.mux_setting = EDBG_CDC_SERCOM_MUX_SETTING;
    b29e:	23c4      	movs	r3, #196	; 0xc4
    b2a0:	039b      	lsls	r3, r3, #14
    b2a2:	9303      	str	r3, [sp, #12]
	config_usart.pinmux_pad0 = EDBG_CDC_SERCOM_PINMUX_PAD0;
    b2a4:	2301      	movs	r3, #1
    b2a6:	425b      	negs	r3, r3
    b2a8:	930c      	str	r3, [sp, #48]	; 0x30
	config_usart.pinmux_pad1 = EDBG_CDC_SERCOM_PINMUX_PAD1;
    b2aa:	930d      	str	r3, [sp, #52]	; 0x34
	config_usart.pinmux_pad2 = EDBG_CDC_SERCOM_PINMUX_PAD2;
    b2ac:	4b1f      	ldr	r3, [pc, #124]	; (b32c <InitializeSerialConsole+0xf8>)
    b2ae:	930e      	str	r3, [sp, #56]	; 0x38
	config_usart.pinmux_pad3 = EDBG_CDC_SERCOM_PINMUX_PAD3;
    b2b0:	4b1f      	ldr	r3, [pc, #124]	; (b330 <InitializeSerialConsole+0xfc>)
    b2b2:	930f      	str	r3, [sp, #60]	; 0x3c
	while (usart_init(&usart_instance,
    b2b4:	4d1f      	ldr	r5, [pc, #124]	; (b334 <InitializeSerialConsole+0x100>)
    b2b6:	4c20      	ldr	r4, [pc, #128]	; (b338 <InitializeSerialConsole+0x104>)
    b2b8:	466a      	mov	r2, sp
    b2ba:	4920      	ldr	r1, [pc, #128]	; (b33c <InitializeSerialConsole+0x108>)
    b2bc:	0028      	movs	r0, r5
    b2be:	47a0      	blx	r4
    b2c0:	2800      	cmp	r0, #0
    b2c2:	d1f9      	bne.n	b2b8 <InitializeSerialConsole+0x84>
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    b2c4:	4d1b      	ldr	r5, [pc, #108]	; (b334 <InitializeSerialConsole+0x100>)
    b2c6:	682c      	ldr	r4, [r5, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    b2c8:	0020      	movs	r0, r4
    b2ca:	4b1d      	ldr	r3, [pc, #116]	; (b340 <InitializeSerialConsole+0x10c>)
    b2cc:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    b2ce:	231f      	movs	r3, #31
    b2d0:	4018      	ands	r0, r3
    b2d2:	3b1e      	subs	r3, #30
    b2d4:	4083      	lsls	r3, r0
    b2d6:	4a1b      	ldr	r2, [pc, #108]	; (b344 <InitializeSerialConsole+0x110>)
    b2d8:	6013      	str	r3, [r2, #0]
	SercomUsart *const usart_hw = &(module->hw->USART);
    b2da:	682a      	ldr	r2, [r5, #0]
	return (usart_hw->SYNCBUSY.reg);
    b2dc:	69d3      	ldr	r3, [r2, #28]
	while (usart_is_syncing(module)) {
    b2de:	2b00      	cmp	r3, #0
    b2e0:	d1fc      	bne.n	b2dc <InitializeSerialConsole+0xa8>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    b2e2:	6823      	ldr	r3, [r4, #0]
    b2e4:	2202      	movs	r2, #2
    b2e6:	4313      	orrs	r3, r2
    b2e8:	6023      	str	r3, [r4, #0]
	usart_register_callback(&usart_instance,
    b2ea:	4c12      	ldr	r4, [pc, #72]	; (b334 <InitializeSerialConsole+0x100>)
    b2ec:	2200      	movs	r2, #0
    b2ee:	4916      	ldr	r1, [pc, #88]	; (b348 <InitializeSerialConsole+0x114>)
    b2f0:	0020      	movs	r0, r4
    b2f2:	4d16      	ldr	r5, [pc, #88]	; (b34c <InitializeSerialConsole+0x118>)
    b2f4:	47a8      	blx	r5
	usart_register_callback(&usart_instance,
    b2f6:	2201      	movs	r2, #1
    b2f8:	4915      	ldr	r1, [pc, #84]	; (b350 <InitializeSerialConsole+0x11c>)
    b2fa:	0020      	movs	r0, r4
    b2fc:	47a8      	blx	r5
{
	/* Sanity check arguments */
	Assert(module);

	/* Enable callback */
	module->callback_enable_mask |= (1 << callback_type);
    b2fe:	2231      	movs	r2, #49	; 0x31
    b300:	5ca3      	ldrb	r3, [r4, r2]
    b302:	2103      	movs	r1, #3
    b304:	430b      	orrs	r3, r1
    b306:	54a3      	strb	r3, [r4, r2]
	usart_read_buffer_job(&usart_instance, (uint8_t*) &latestRx, 1);	//Kicks off constant reading of characters
    b308:	3a30      	subs	r2, #48	; 0x30
    b30a:	4912      	ldr	r1, [pc, #72]	; (b354 <InitializeSerialConsole+0x120>)
    b30c:	0020      	movs	r0, r4
    b30e:	4b12      	ldr	r3, [pc, #72]	; (b358 <InitializeSerialConsole+0x124>)
    b310:	4798      	blx	r3
}
    b312:	b011      	add	sp, #68	; 0x44
    b314:	bd30      	pop	{r4, r5, pc}
    b316:	46c0      	nop			; (mov r8, r8)
    b318:	2000037c 	.word	0x2000037c
    b31c:	0000b181 	.word	0x0000b181
    b320:	20000174 	.word	0x20000174
    b324:	2000017c 	.word	0x2000017c
    b328:	20000580 	.word	0x20000580
    b32c:	002a0003 	.word	0x002a0003
    b330:	002b0003 	.word	0x002b0003
    b334:	20000140 	.word	0x20000140
    b338:	0000bdc9 	.word	0x0000bdc9
    b33c:	42001800 	.word	0x42001800
    b340:	0000b991 	.word	0x0000b991
    b344:	e000e100 	.word	0xe000e100
    b348:	0000b205 	.word	0x0000b205
    b34c:	0000c199 	.word	0x0000c199
    b350:	0000b3d1 	.word	0x0000b3d1
    b354:	20000178 	.word	0x20000178
    b358:	0000c1d1 	.word	0x0000c1d1

0000b35c <SerialConsoleWriteString>:
{
    b35c:	b5f0      	push	{r4, r5, r6, r7, lr}
    b35e:	46c6      	mov	lr, r8
    b360:	b500      	push	{lr}
    b362:	0005      	movs	r5, r0
    b364:	2400      	movs	r4, #0
	if(string != NULL)
    b366:	2800      	cmp	r0, #0
    b368:	d012      	beq.n	b390 <SerialConsoleWriteString+0x34>
		for (size_t iter = 0; iter < strlen(string); iter++)
    b36a:	4e11      	ldr	r6, [pc, #68]	; (b3b0 <SerialConsoleWriteString+0x54>)
			circular_buf_put(cbufTx, string[iter]);
    b36c:	4f11      	ldr	r7, [pc, #68]	; (b3b4 <SerialConsoleWriteString+0x58>)
    b36e:	4b12      	ldr	r3, [pc, #72]	; (b3b8 <SerialConsoleWriteString+0x5c>)
    b370:	4698      	mov	r8, r3
    b372:	e003      	b.n	b37c <SerialConsoleWriteString+0x20>
    b374:	5d29      	ldrb	r1, [r5, r4]
    b376:	6838      	ldr	r0, [r7, #0]
    b378:	47c0      	blx	r8
		for (size_t iter = 0; iter < strlen(string); iter++)
    b37a:	3401      	adds	r4, #1
    b37c:	0028      	movs	r0, r5
    b37e:	47b0      	blx	r6
    b380:	4284      	cmp	r4, r0
    b382:	d3f7      	bcc.n	b374 <SerialConsoleWriteString+0x18>
		if(usart_get_job_status(&usart_instance, USART_TRANSCEIVER_TX) == STATUS_OK)
    b384:	2101      	movs	r1, #1
    b386:	480d      	ldr	r0, [pc, #52]	; (b3bc <SerialConsoleWriteString+0x60>)
    b388:	4b0d      	ldr	r3, [pc, #52]	; (b3c0 <SerialConsoleWriteString+0x64>)
    b38a:	4798      	blx	r3
    b38c:	2800      	cmp	r0, #0
    b38e:	d002      	beq.n	b396 <SerialConsoleWriteString+0x3a>
}
    b390:	bc04      	pop	{r2}
    b392:	4690      	mov	r8, r2
    b394:	bdf0      	pop	{r4, r5, r6, r7, pc}
			circular_buf_get(cbufTx, (uint8_t*) &latestTx); //Perform only if the SERCOM TX is free (not busy)
    b396:	4c0b      	ldr	r4, [pc, #44]	; (b3c4 <SerialConsoleWriteString+0x68>)
    b398:	4b06      	ldr	r3, [pc, #24]	; (b3b4 <SerialConsoleWriteString+0x58>)
    b39a:	6818      	ldr	r0, [r3, #0]
    b39c:	0021      	movs	r1, r4
    b39e:	4b0a      	ldr	r3, [pc, #40]	; (b3c8 <SerialConsoleWriteString+0x6c>)
    b3a0:	4798      	blx	r3
			usart_write_buffer_job(&usart_instance, (uint8_t*) &latestTx, 1);
    b3a2:	2201      	movs	r2, #1
    b3a4:	0021      	movs	r1, r4
    b3a6:	4805      	ldr	r0, [pc, #20]	; (b3bc <SerialConsoleWriteString+0x60>)
    b3a8:	4b08      	ldr	r3, [pc, #32]	; (b3cc <SerialConsoleWriteString+0x70>)
    b3aa:	4798      	blx	r3
}
    b3ac:	e7f0      	b.n	b390 <SerialConsoleWriteString+0x34>
    b3ae:	46c0      	nop			; (mov r8, r8)
    b3b0:	0000d205 	.word	0x0000d205
    b3b4:	20000580 	.word	0x20000580
    b3b8:	0000b1a1 	.word	0x0000b1a1
    b3bc:	20000140 	.word	0x20000140
    b3c0:	0000c1f1 	.word	0x0000c1f1
    b3c4:	2000057c 	.word	0x2000057c
    b3c8:	0000b1cd 	.word	0x0000b1cd
    b3cc:	0000c1b1 	.word	0x0000c1b1

0000b3d0 <usart_read_callback>:
{
    b3d0:	b510      	push	{r4, lr}
    b3d2:	b082      	sub	sp, #8
	SerialConsoleWriteString(&latestRx);
    b3d4:	4c0d      	ldr	r4, [pc, #52]	; (b40c <usart_read_callback+0x3c>)
    b3d6:	0020      	movs	r0, r4
    b3d8:	4b0d      	ldr	r3, [pc, #52]	; (b410 <usart_read_callback+0x40>)
    b3da:	4798      	blx	r3
	if(latestRx == 0x08)
    b3dc:	7823      	ldrb	r3, [r4, #0]
    b3de:	2b08      	cmp	r3, #8
    b3e0:	d00c      	beq.n	b3fc <usart_read_callback+0x2c>
	circular_buf_put(cbufRx, (uint8_t) latestRx); //Add the latest read character into the RX circular Buffer
    b3e2:	4c0a      	ldr	r4, [pc, #40]	; (b40c <usart_read_callback+0x3c>)
    b3e4:	7821      	ldrb	r1, [r4, #0]
    b3e6:	4b0b      	ldr	r3, [pc, #44]	; (b414 <usart_read_callback+0x44>)
    b3e8:	6818      	ldr	r0, [r3, #0]
    b3ea:	4b0b      	ldr	r3, [pc, #44]	; (b418 <usart_read_callback+0x48>)
    b3ec:	4798      	blx	r3
	usart_read_buffer_job(&usart_instance, (uint8_t*) &latestRx, 1);	//Order the MCU to keep reading
    b3ee:	2201      	movs	r2, #1
    b3f0:	0021      	movs	r1, r4
    b3f2:	480a      	ldr	r0, [pc, #40]	; (b41c <usart_read_callback+0x4c>)
    b3f4:	4b0a      	ldr	r3, [pc, #40]	; (b420 <usart_read_callback+0x50>)
    b3f6:	4798      	blx	r3
}
    b3f8:	b002      	add	sp, #8
    b3fa:	bd10      	pop	{r4, pc}
	a[0] = 0x20;
    b3fc:	a801      	add	r0, sp, #4
    b3fe:	3318      	adds	r3, #24
    b400:	7003      	strb	r3, [r0, #0]
	a[1]= 0x08;
    b402:	3b18      	subs	r3, #24
    b404:	7043      	strb	r3, [r0, #1]
	SerialConsoleWriteString(&a);
    b406:	4b02      	ldr	r3, [pc, #8]	; (b410 <usart_read_callback+0x40>)
    b408:	4798      	blx	r3
    b40a:	e7ea      	b.n	b3e2 <usart_read_callback+0x12>
    b40c:	20000178 	.word	0x20000178
    b410:	0000b35d 	.word	0x0000b35d
    b414:	20000174 	.word	0x20000174
    b418:	0000b1a1 	.word	0x0000b1a1
    b41c:	20000140 	.word	0x20000140
    b420:	0000c1d1 	.word	0x0000c1d1

0000b424 <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
    b424:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
    b426:	2204      	movs	r2, #4
    b428:	4b03      	ldr	r3, [pc, #12]	; (b438 <sd_mmc_init+0x14>)
    b42a:	729a      	strb	r2, [r3, #10]
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
    b42c:	32fb      	adds	r2, #251	; 0xfb
    b42e:	4b03      	ldr	r3, [pc, #12]	; (b43c <sd_mmc_init+0x18>)
    b430:	701a      	strb	r2, [r3, #0]
	driver_init();
    b432:	4b03      	ldr	r3, [pc, #12]	; (b440 <sd_mmc_init+0x1c>)
    b434:	4798      	blx	r3
}
    b436:	bd10      	pop	{r4, pc}
    b438:	20000090 	.word	0x20000090
    b43c:	200000b0 	.word	0x200000b0
    b440:	0000b445 	.word	0x0000b445

0000b444 <sd_mmc_spi_init>:
{
	spi_reset(&sd_mmc_master);
}

void sd_mmc_spi_init(void)
{
    b444:	b570      	push	{r4, r5, r6, lr}
    b446:	b090      	sub	sp, #64	; 0x40
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
    b448:	2300      	movs	r3, #0
    b44a:	4a2d      	ldr	r2, [pc, #180]	; (b500 <sd_mmc_spi_init+0xbc>)
    b44c:	7013      	strb	r3, [r2, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
    b44e:	ac02      	add	r4, sp, #8
    b450:	2501      	movs	r5, #1
    b452:	7025      	strb	r5, [r4, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
    b454:	9303      	str	r3, [sp, #12]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
    b456:	9304      	str	r3, [sp, #16]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
    b458:	7423      	strb	r3, [r4, #16]
	config->run_in_standby   = false;
    b45a:	7463      	strb	r3, [r4, #17]
	config->receiver_enable  = true;
    b45c:	74a5      	strb	r5, [r4, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
    b45e:	74e5      	strb	r5, [r4, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
    b460:	7523      	strb	r3, [r4, #20]
#  endif
	config->generator_source = GCLK_GENERATOR_0;
    b462:	2224      	movs	r2, #36	; 0x24
    b464:	54a3      	strb	r3, [r4, r2]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
    b466:	3a18      	subs	r2, #24
    b468:	2100      	movs	r1, #0
    b46a:	a808      	add	r0, sp, #32
    b46c:	4b25      	ldr	r3, [pc, #148]	; (b504 <sd_mmc_spi_init+0xc0>)
    b46e:	4798      	blx	r3

	// Initialize SPI interface and enable it
	struct spi_config config;
	spi_get_config_defaults(&config);

	config.mux_setting = SD_MMC_SPI_PINMUX_SETTING;
    b470:	2380      	movs	r3, #128	; 0x80
    b472:	025b      	lsls	r3, r3, #9
    b474:	60e3      	str	r3, [r4, #12]
	config.pinmux_pad0 = SD_MMC_SPI_PINMUX_PAD0;
    b476:	4b24      	ldr	r3, [pc, #144]	; (b508 <sd_mmc_spi_init+0xc4>)
    b478:	62a3      	str	r3, [r4, #40]	; 0x28
	config.pinmux_pad1 = SD_MMC_SPI_PINMUX_PAD1;
    b47a:	4b24      	ldr	r3, [pc, #144]	; (b50c <sd_mmc_spi_init+0xc8>)
    b47c:	62e3      	str	r3, [r4, #44]	; 0x2c
	config.pinmux_pad2 = SD_MMC_SPI_PINMUX_PAD2;
    b47e:	4b24      	ldr	r3, [pc, #144]	; (b510 <sd_mmc_spi_init+0xcc>)
    b480:	6323      	str	r3, [r4, #48]	; 0x30
	config.pinmux_pad3 = SD_MMC_SPI_PINMUX_PAD3;
    b482:	4b24      	ldr	r3, [pc, #144]	; (b514 <sd_mmc_spi_init+0xd0>)
    b484:	6363      	str	r3, [r4, #52]	; 0x34
	config.generator_source = SD_MMC_SPI_SOURCE_CLOCK;
	config.mode_specific.master.baudrate = SDMMC_CLOCK_INIT;
    b486:	4b24      	ldr	r3, [pc, #144]	; (b518 <sd_mmc_spi_init+0xd4>)
    b488:	61a3      	str	r3, [r4, #24]

	spi_init(&sd_mmc_master, SD_MMC_SPI, &config);
    b48a:	4e24      	ldr	r6, [pc, #144]	; (b51c <sd_mmc_spi_init+0xd8>)
    b48c:	0022      	movs	r2, r4
    b48e:	4924      	ldr	r1, [pc, #144]	; (b520 <sd_mmc_spi_init+0xdc>)
    b490:	0030      	movs	r0, r6
    b492:	4b24      	ldr	r3, [pc, #144]	; (b524 <sd_mmc_spi_init+0xe0>)
    b494:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    b496:	6834      	ldr	r4, [r6, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    b498:	0020      	movs	r0, r4
    b49a:	4b23      	ldr	r3, [pc, #140]	; (b528 <sd_mmc_spi_init+0xe4>)
    b49c:	4798      	blx	r3
    b49e:	231f      	movs	r3, #31
    b4a0:	4018      	ands	r0, r3
    b4a2:	4085      	lsls	r5, r0
    b4a4:	4b21      	ldr	r3, [pc, #132]	; (b52c <sd_mmc_spi_init+0xe8>)
    b4a6:	601d      	str	r5, [r3, #0]
	SercomSpi *const spi_module = &(module->hw->SPI);
    b4a8:	6832      	ldr	r2, [r6, #0]
	return (spi_module->SYNCBUSY.reg);
    b4aa:	69d3      	ldr	r3, [r2, #28]
#  endif

	while (spi_is_syncing(module)) {
    b4ac:	2b00      	cmp	r3, #0
    b4ae:	d1fc      	bne.n	b4aa <sd_mmc_spi_init+0x66>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    b4b0:	6823      	ldr	r3, [r4, #0]
    b4b2:	2202      	movs	r2, #2
    b4b4:	4313      	orrs	r3, r2
    b4b6:	6023      	str	r3, [r4, #0]
	config->address_enabled = false;
    b4b8:	4a1d      	ldr	r2, [pc, #116]	; (b530 <sd_mmc_spi_init+0xec>)
    b4ba:	2300      	movs	r3, #0
    b4bc:	7053      	strb	r3, [r2, #1]
	config->address         = 0;
    b4be:	7093      	strb	r3, [r2, #2]
	spi_enable(&sd_mmc_master);

	spi_slave_inst_get_config_defaults(&slave_configs[0]);
	slave_configs[0].ss_pin = ss_pins[0];
    b4c0:	491c      	ldr	r1, [pc, #112]	; (b534 <sd_mmc_spi_init+0xf0>)
    b4c2:	7808      	ldrb	r0, [r1, #0]
    b4c4:	7010      	strb	r0, [r2, #0]
	slave->ss_pin          = config->ss_pin;
    b4c6:	4c1c      	ldr	r4, [pc, #112]	; (b538 <sd_mmc_spi_init+0xf4>)
    b4c8:	7020      	strb	r0, [r4, #0]
	slave->address_enabled = config->address_enabled;
    b4ca:	7063      	strb	r3, [r4, #1]
	slave->address         = config->address;
    b4cc:	70a3      	strb	r3, [r4, #2]
	config->input_pull = PORT_PIN_PULL_UP;
    b4ce:	a901      	add	r1, sp, #4
    b4d0:	2201      	movs	r2, #1
    b4d2:	704a      	strb	r2, [r1, #1]
	config->powersave  = false;
    b4d4:	708b      	strb	r3, [r1, #2]
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
    b4d6:	700a      	strb	r2, [r1, #0]
	port_pin_set_config(slave->ss_pin, &pin_conf);
    b4d8:	4b18      	ldr	r3, [pc, #96]	; (b53c <sd_mmc_spi_init+0xf8>)
    b4da:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
    b4dc:	7822      	ldrb	r2, [r4, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    b4de:	09d1      	lsrs	r1, r2, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    b4e0:	2300      	movs	r3, #0
	if (port_index < PORT_INST_NUM) {
    b4e2:	2900      	cmp	r1, #0
    b4e4:	d104      	bne.n	b4f0 <sd_mmc_spi_init+0xac>
		return &(ports[port_index]->Group[group_index]);
    b4e6:	0953      	lsrs	r3, r2, #5
    b4e8:	01db      	lsls	r3, r3, #7
    b4ea:	4915      	ldr	r1, [pc, #84]	; (b540 <sd_mmc_spi_init+0xfc>)
    b4ec:	468c      	mov	ip, r1
    b4ee:	4463      	add	r3, ip
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    b4f0:	211f      	movs	r1, #31
    b4f2:	4011      	ands	r1, r2
    b4f4:	2201      	movs	r2, #1
    b4f6:	408a      	lsls	r2, r1
		port_base->OUTSET.reg = pin_mask;
    b4f8:	619a      	str	r2, [r3, #24]
	spi_attach_slave(&sd_mmc_spi_devices[0], &slave_configs[0]);
}
    b4fa:	b010      	add	sp, #64	; 0x40
    b4fc:	bd70      	pop	{r4, r5, r6, pc}
    b4fe:	46c0      	nop			; (mov r8, r8)
    b500:	200000f3 	.word	0x200000f3
    b504:	0000d115 	.word	0x0000d115
    b508:	00100002 	.word	0x00100002
    b50c:	00110002 	.word	0x00110002
    b510:	00120002 	.word	0x00120002
    b514:	00130002 	.word	0x00130002
    b518:	00061a80 	.word	0x00061a80
    b51c:	200000b4 	.word	0x200000b4
    b520:	42000c00 	.word	0x42000c00
    b524:	0000ba21 	.word	0x0000ba21
    b528:	0000b991 	.word	0x0000b991
    b52c:	e000e100 	.word	0xe000e100
    b530:	200000f4 	.word	0x200000f4
    b534:	2000000c 	.word	0x2000000c
    b538:	200000f0 	.word	0x200000f0
    b53c:	0000b5b9 	.word	0x0000b5b9
    b540:	41004400 	.word	0x41004400

0000b544 <delay_init>:
 *
 * Not used in cycle mode.
 */
void delay_init(void)
{
}
    b544:	4770      	bx	lr
	...

0000b548 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    b548:	4b0c      	ldr	r3, [pc, #48]	; (b57c <cpu_irq_enter_critical+0x34>)
    b54a:	681b      	ldr	r3, [r3, #0]
    b54c:	2b00      	cmp	r3, #0
    b54e:	d106      	bne.n	b55e <cpu_irq_enter_critical+0x16>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    b550:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
    b554:	2b00      	cmp	r3, #0
    b556:	d007      	beq.n	b568 <cpu_irq_enter_critical+0x20>
			cpu_irq_disable();
			cpu_irq_prev_interrupt_state = true;
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    b558:	2200      	movs	r2, #0
    b55a:	4b09      	ldr	r3, [pc, #36]	; (b580 <cpu_irq_enter_critical+0x38>)
    b55c:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    b55e:	4a07      	ldr	r2, [pc, #28]	; (b57c <cpu_irq_enter_critical+0x34>)
    b560:	6813      	ldr	r3, [r2, #0]
    b562:	3301      	adds	r3, #1
    b564:	6013      	str	r3, [r2, #0]
}
    b566:	4770      	bx	lr
  __ASM volatile ("cpsid i" : : : "memory");
    b568:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    b56a:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    b56e:	2200      	movs	r2, #0
    b570:	4b04      	ldr	r3, [pc, #16]	; (b584 <cpu_irq_enter_critical+0x3c>)
    b572:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    b574:	3201      	adds	r2, #1
    b576:	4b02      	ldr	r3, [pc, #8]	; (b580 <cpu_irq_enter_critical+0x38>)
    b578:	701a      	strb	r2, [r3, #0]
    b57a:	e7f0      	b.n	b55e <cpu_irq_enter_critical+0x16>
    b57c:	200000f8 	.word	0x200000f8
    b580:	200000fc 	.word	0x200000fc
    b584:	2000000d 	.word	0x2000000d

0000b588 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    b588:	4b08      	ldr	r3, [pc, #32]	; (b5ac <cpu_irq_leave_critical+0x24>)
    b58a:	681a      	ldr	r2, [r3, #0]
    b58c:	3a01      	subs	r2, #1
    b58e:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    b590:	681b      	ldr	r3, [r3, #0]
    b592:	2b00      	cmp	r3, #0
    b594:	d109      	bne.n	b5aa <cpu_irq_leave_critical+0x22>
    b596:	4b06      	ldr	r3, [pc, #24]	; (b5b0 <cpu_irq_leave_critical+0x28>)
    b598:	781b      	ldrb	r3, [r3, #0]
    b59a:	2b00      	cmp	r3, #0
    b59c:	d005      	beq.n	b5aa <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    b59e:	2201      	movs	r2, #1
    b5a0:	4b04      	ldr	r3, [pc, #16]	; (b5b4 <cpu_irq_leave_critical+0x2c>)
    b5a2:	701a      	strb	r2, [r3, #0]
    b5a4:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
    b5a8:	b662      	cpsie	i
	}
}
    b5aa:	4770      	bx	lr
    b5ac:	200000f8 	.word	0x200000f8
    b5b0:	200000fc 	.word	0x200000fc
    b5b4:	2000000d 	.word	0x2000000d

0000b5b8 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    b5b8:	b500      	push	{lr}
    b5ba:	b083      	sub	sp, #12
	config->mux_position = SYSTEM_PINMUX_GPIO;
    b5bc:	ab01      	add	r3, sp, #4
    b5be:	2280      	movs	r2, #128	; 0x80
    b5c0:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    b5c2:	780a      	ldrb	r2, [r1, #0]
    b5c4:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    b5c6:	784a      	ldrb	r2, [r1, #1]
    b5c8:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    b5ca:	788a      	ldrb	r2, [r1, #2]
    b5cc:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    b5ce:	0019      	movs	r1, r3
    b5d0:	4b01      	ldr	r3, [pc, #4]	; (b5d8 <port_pin_set_config+0x20>)
    b5d2:	4798      	blx	r3
}
    b5d4:	b003      	add	sp, #12
    b5d6:	bd00      	pop	{pc}
    b5d8:	0000cad5 	.word	0x0000cad5

0000b5dc <long_division>:
/**
 * \internal Calculate 64 bit division, ref can be found in
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
    b5dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    b5de:	46de      	mov	lr, fp
    b5e0:	4657      	mov	r7, sl
    b5e2:	464e      	mov	r6, r9
    b5e4:	4645      	mov	r5, r8
    b5e6:	b5e0      	push	{r5, r6, r7, lr}
    b5e8:	b087      	sub	sp, #28
    b5ea:	4680      	mov	r8, r0
    b5ec:	9104      	str	r1, [sp, #16]
    b5ee:	0016      	movs	r6, r2
    b5f0:	001f      	movs	r7, r3
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    b5f2:	2200      	movs	r2, #0
    b5f4:	2300      	movs	r3, #0
    b5f6:	2100      	movs	r1, #0
    b5f8:	468b      	mov	fp, r1
	for (i = 63; i >= 0; i--) {
    b5fa:	243f      	movs	r4, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
    b5fc:	2001      	movs	r0, #1
    b5fe:	0021      	movs	r1, r4
    b600:	9600      	str	r6, [sp, #0]
    b602:	9701      	str	r7, [sp, #4]
    b604:	465c      	mov	r4, fp
    b606:	9403      	str	r4, [sp, #12]
    b608:	4644      	mov	r4, r8
    b60a:	9405      	str	r4, [sp, #20]
    b60c:	e013      	b.n	b636 <long_division+0x5a>
    b60e:	2420      	movs	r4, #32
    b610:	1a64      	subs	r4, r4, r1
    b612:	0005      	movs	r5, r0
    b614:	40e5      	lsrs	r5, r4
    b616:	46a8      	mov	r8, r5
    b618:	e014      	b.n	b644 <long_division+0x68>
		if (n & bit_shift) {
			r |= 0x01;
		}

		if (r >= d) {
			r = r - d;
    b61a:	9c00      	ldr	r4, [sp, #0]
    b61c:	9d01      	ldr	r5, [sp, #4]
    b61e:	1b12      	subs	r2, r2, r4
    b620:	41ab      	sbcs	r3, r5
			q |= bit_shift;
    b622:	465c      	mov	r4, fp
    b624:	464d      	mov	r5, r9
    b626:	432c      	orrs	r4, r5
    b628:	46a3      	mov	fp, r4
    b62a:	9c03      	ldr	r4, [sp, #12]
    b62c:	4645      	mov	r5, r8
    b62e:	432c      	orrs	r4, r5
    b630:	9403      	str	r4, [sp, #12]
	for (i = 63; i >= 0; i--) {
    b632:	3901      	subs	r1, #1
    b634:	d325      	bcc.n	b682 <long_division+0xa6>
		bit_shift = (uint64_t)1 << i;
    b636:	2420      	movs	r4, #32
    b638:	4264      	negs	r4, r4
    b63a:	190c      	adds	r4, r1, r4
    b63c:	d4e7      	bmi.n	b60e <long_division+0x32>
    b63e:	0005      	movs	r5, r0
    b640:	40a5      	lsls	r5, r4
    b642:	46a8      	mov	r8, r5
    b644:	0004      	movs	r4, r0
    b646:	408c      	lsls	r4, r1
    b648:	46a1      	mov	r9, r4
		r = r << 1;
    b64a:	1892      	adds	r2, r2, r2
    b64c:	415b      	adcs	r3, r3
    b64e:	0014      	movs	r4, r2
    b650:	001d      	movs	r5, r3
		if (n & bit_shift) {
    b652:	9e05      	ldr	r6, [sp, #20]
    b654:	464f      	mov	r7, r9
    b656:	403e      	ands	r6, r7
    b658:	46b4      	mov	ip, r6
    b65a:	9e04      	ldr	r6, [sp, #16]
    b65c:	4647      	mov	r7, r8
    b65e:	403e      	ands	r6, r7
    b660:	46b2      	mov	sl, r6
    b662:	4666      	mov	r6, ip
    b664:	4657      	mov	r7, sl
    b666:	433e      	orrs	r6, r7
    b668:	d003      	beq.n	b672 <long_division+0x96>
			r |= 0x01;
    b66a:	0006      	movs	r6, r0
    b66c:	4326      	orrs	r6, r4
    b66e:	0032      	movs	r2, r6
    b670:	002b      	movs	r3, r5
		if (r >= d) {
    b672:	9c00      	ldr	r4, [sp, #0]
    b674:	9d01      	ldr	r5, [sp, #4]
    b676:	429d      	cmp	r5, r3
    b678:	d8db      	bhi.n	b632 <long_division+0x56>
    b67a:	d1ce      	bne.n	b61a <long_division+0x3e>
    b67c:	4294      	cmp	r4, r2
    b67e:	d8d8      	bhi.n	b632 <long_division+0x56>
    b680:	e7cb      	b.n	b61a <long_division+0x3e>
    b682:	9b03      	ldr	r3, [sp, #12]
		}
	}

	return q;
}
    b684:	4658      	mov	r0, fp
    b686:	0019      	movs	r1, r3
    b688:	b007      	add	sp, #28
    b68a:	bc3c      	pop	{r2, r3, r4, r5}
    b68c:	4690      	mov	r8, r2
    b68e:	4699      	mov	r9, r3
    b690:	46a2      	mov	sl, r4
    b692:	46ab      	mov	fp, r5
    b694:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000b696 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
    b696:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    b698:	0849      	lsrs	r1, r1, #1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    b69a:	2340      	movs	r3, #64	; 0x40
    b69c:	2400      	movs	r4, #0
	if (baudrate > (external_clock / 2)) {
    b69e:	4281      	cmp	r1, r0
    b6a0:	d202      	bcs.n	b6a8 <_sercom_get_sync_baud_val+0x12>
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
		return STATUS_OK;
	}
}
    b6a2:	0018      	movs	r0, r3
    b6a4:	bd10      	pop	{r4, pc}
		baud_calculated++;
    b6a6:	001c      	movs	r4, r3
		clock_value = clock_value - baudrate;
    b6a8:	1a09      	subs	r1, r1, r0
		baud_calculated++;
    b6aa:	1c63      	adds	r3, r4, #1
    b6ac:	b29b      	uxth	r3, r3
	while (clock_value >= baudrate) {
    b6ae:	4288      	cmp	r0, r1
    b6b0:	d9f9      	bls.n	b6a6 <_sercom_get_sync_baud_val+0x10>
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    b6b2:	2340      	movs	r3, #64	; 0x40
	if (baud_calculated > 0xFF) {
    b6b4:	2cff      	cmp	r4, #255	; 0xff
    b6b6:	d8f4      	bhi.n	b6a2 <_sercom_get_sync_baud_val+0xc>
		*baudvalue = baud_calculated;
    b6b8:	8014      	strh	r4, [r2, #0]
		return STATUS_OK;
    b6ba:	2300      	movs	r3, #0
    b6bc:	e7f1      	b.n	b6a2 <_sercom_get_sync_baud_val+0xc>
	...

0000b6c0 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
    b6c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    b6c2:	b083      	sub	sp, #12
    b6c4:	000f      	movs	r7, r1
    b6c6:	0016      	movs	r6, r2
    b6c8:	aa08      	add	r2, sp, #32
    b6ca:	7811      	ldrb	r1, [r2, #0]
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    b6cc:	0004      	movs	r4, r0
    b6ce:	434c      	muls	r4, r1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    b6d0:	2240      	movs	r2, #64	; 0x40
	if ((baudrate * sample_num) > peripheral_clock) {
    b6d2:	42bc      	cmp	r4, r7
    b6d4:	d902      	bls.n	b6dc <_sercom_get_async_baud_val+0x1c>
		baud_calculated = baud_int | (baud_fp << 13);
	}

	*baudval = baud_calculated;
	return STATUS_OK;
}
    b6d6:	0010      	movs	r0, r2
    b6d8:	b003      	add	sp, #12
    b6da:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
    b6dc:	2b00      	cmp	r3, #0
    b6de:	d114      	bne.n	b70a <_sercom_get_async_baud_val+0x4a>
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
    b6e0:	0002      	movs	r2, r0
    b6e2:	0008      	movs	r0, r1
    b6e4:	2100      	movs	r1, #0
    b6e6:	4c19      	ldr	r4, [pc, #100]	; (b74c <_sercom_get_async_baud_val+0x8c>)
    b6e8:	47a0      	blx	r4
    b6ea:	0001      	movs	r1, r0
		ratio = long_division(temp1, peripheral_clock);
    b6ec:	003a      	movs	r2, r7
    b6ee:	2300      	movs	r3, #0
    b6f0:	2000      	movs	r0, #0
    b6f2:	4c17      	ldr	r4, [pc, #92]	; (b750 <_sercom_get_async_baud_val+0x90>)
    b6f4:	47a0      	blx	r4
		scale = ((uint64_t)1 << SHIFT) - ratio;
    b6f6:	2200      	movs	r2, #0
    b6f8:	2301      	movs	r3, #1
    b6fa:	1a12      	subs	r2, r2, r0
    b6fc:	418b      	sbcs	r3, r1
		baud_calculated = (65536 * scale) >> SHIFT;
    b6fe:	0c12      	lsrs	r2, r2, #16
    b700:	041b      	lsls	r3, r3, #16
    b702:	431a      	orrs	r2, r3
	*baudval = baud_calculated;
    b704:	8032      	strh	r2, [r6, #0]
	return STATUS_OK;
    b706:	2200      	movs	r2, #0
    b708:	e7e5      	b.n	b6d6 <_sercom_get_async_baud_val+0x16>
	uint64_t baud_calculated = 0;
    b70a:	2200      	movs	r2, #0
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
    b70c:	2b01      	cmp	r3, #1
    b70e:	d1f9      	bne.n	b704 <_sercom_get_async_baud_val+0x44>
		temp1 = ((uint64_t)baudrate * sample_num);
    b710:	000a      	movs	r2, r1
    b712:	2300      	movs	r3, #0
    b714:	2100      	movs	r1, #0
    b716:	4c0d      	ldr	r4, [pc, #52]	; (b74c <_sercom_get_async_baud_val+0x8c>)
    b718:	47a0      	blx	r4
    b71a:	0002      	movs	r2, r0
    b71c:	000b      	movs	r3, r1
    b71e:	9200      	str	r2, [sp, #0]
    b720:	9301      	str	r3, [sp, #4]
		baud_int = long_division( peripheral_clock, temp1);
    b722:	0038      	movs	r0, r7
    b724:	2100      	movs	r1, #0
    b726:	4c0a      	ldr	r4, [pc, #40]	; (b750 <_sercom_get_async_baud_val+0x90>)
    b728:	47a0      	blx	r4
    b72a:	0005      	movs	r5, r0
		if(baud_int > BAUD_INT_MAX) {
    b72c:	2380      	movs	r3, #128	; 0x80
    b72e:	019b      	lsls	r3, r3, #6
				return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    b730:	2240      	movs	r2, #64	; 0x40
		if(baud_int > BAUD_INT_MAX) {
    b732:	4298      	cmp	r0, r3
    b734:	d8cf      	bhi.n	b6d6 <_sercom_get_async_baud_val+0x16>
		temp1 = long_division( 8 * (uint64_t)peripheral_clock, temp1);
    b736:	0f79      	lsrs	r1, r7, #29
    b738:	00f8      	lsls	r0, r7, #3
    b73a:	9a00      	ldr	r2, [sp, #0]
    b73c:	9b01      	ldr	r3, [sp, #4]
    b73e:	47a0      	blx	r4
		baud_fp = temp1 - 8 * baud_int;
    b740:	00ea      	lsls	r2, r5, #3
    b742:	1a82      	subs	r2, r0, r2
		baud_calculated = baud_int | (baud_fp << 13);
    b744:	b2d2      	uxtb	r2, r2
    b746:	0352      	lsls	r2, r2, #13
    b748:	432a      	orrs	r2, r5
    b74a:	e7db      	b.n	b704 <_sercom_get_async_baud_val+0x44>
    b74c:	0000ce91 	.word	0x0000ce91
    b750:	0000b5dd 	.word	0x0000b5dd

0000b754 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    b754:	b510      	push	{r4, lr}
    b756:	b082      	sub	sp, #8
    b758:	0004      	movs	r4, r0
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    b75a:	4b0e      	ldr	r3, [pc, #56]	; (b794 <sercom_set_gclk_generator+0x40>)
    b75c:	781b      	ldrb	r3, [r3, #0]
    b75e:	2b00      	cmp	r3, #0
    b760:	d007      	beq.n	b772 <sercom_set_gclk_generator+0x1e>
    b762:	2900      	cmp	r1, #0
    b764:	d105      	bne.n	b772 <sercom_set_gclk_generator+0x1e>
		/* Save config */
		_sercom_config.generator_source = generator_source;
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
    b766:	4b0b      	ldr	r3, [pc, #44]	; (b794 <sercom_set_gclk_generator+0x40>)
    b768:	785b      	ldrb	r3, [r3, #1]
    b76a:	4283      	cmp	r3, r0
    b76c:	d010      	beq.n	b790 <sercom_set_gclk_generator+0x3c>
		/* Return status OK if same config */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
    b76e:	201d      	movs	r0, #29
    b770:	e00c      	b.n	b78c <sercom_set_gclk_generator+0x38>
		gclk_chan_conf.source_generator = generator_source;
    b772:	a901      	add	r1, sp, #4
    b774:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    b776:	2013      	movs	r0, #19
    b778:	4b07      	ldr	r3, [pc, #28]	; (b798 <sercom_set_gclk_generator+0x44>)
    b77a:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    b77c:	2013      	movs	r0, #19
    b77e:	4b07      	ldr	r3, [pc, #28]	; (b79c <sercom_set_gclk_generator+0x48>)
    b780:	4798      	blx	r3
		_sercom_config.generator_source = generator_source;
    b782:	4b04      	ldr	r3, [pc, #16]	; (b794 <sercom_set_gclk_generator+0x40>)
    b784:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
    b786:	2201      	movs	r2, #1
    b788:	701a      	strb	r2, [r3, #0]
		return STATUS_OK;
    b78a:	2000      	movs	r0, #0
}
    b78c:	b002      	add	sp, #8
    b78e:	bd10      	pop	{r4, pc}
		return STATUS_OK;
    b790:	2000      	movs	r0, #0
    b792:	e7fb      	b.n	b78c <sercom_set_gclk_generator+0x38>
    b794:	20000100 	.word	0x20000100
    b798:	0000c9dd 	.word	0x0000c9dd
    b79c:	0000c951 	.word	0x0000c951

0000b7a0 <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
    b7a0:	4b40      	ldr	r3, [pc, #256]	; (b8a4 <_sercom_get_default_pad+0x104>)
    b7a2:	4298      	cmp	r0, r3
    b7a4:	d031      	beq.n	b80a <_sercom_get_default_pad+0x6a>
    b7a6:	d90a      	bls.n	b7be <_sercom_get_default_pad+0x1e>
    b7a8:	4b3f      	ldr	r3, [pc, #252]	; (b8a8 <_sercom_get_default_pad+0x108>)
    b7aa:	4298      	cmp	r0, r3
    b7ac:	d04d      	beq.n	b84a <_sercom_get_default_pad+0xaa>
    b7ae:	4b3f      	ldr	r3, [pc, #252]	; (b8ac <_sercom_get_default_pad+0x10c>)
    b7b0:	4298      	cmp	r0, r3
    b7b2:	d05a      	beq.n	b86a <_sercom_get_default_pad+0xca>
    b7b4:	4b3e      	ldr	r3, [pc, #248]	; (b8b0 <_sercom_get_default_pad+0x110>)
    b7b6:	4298      	cmp	r0, r3
    b7b8:	d037      	beq.n	b82a <_sercom_get_default_pad+0x8a>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
	}

	Assert(false);
	return 0;
    b7ba:	2000      	movs	r0, #0
}
    b7bc:	4770      	bx	lr
	switch ((uintptr_t)sercom_module) {
    b7be:	4b3d      	ldr	r3, [pc, #244]	; (b8b4 <_sercom_get_default_pad+0x114>)
    b7c0:	4298      	cmp	r0, r3
    b7c2:	d00c      	beq.n	b7de <_sercom_get_default_pad+0x3e>
    b7c4:	4b3c      	ldr	r3, [pc, #240]	; (b8b8 <_sercom_get_default_pad+0x118>)
    b7c6:	4298      	cmp	r0, r3
    b7c8:	d1f7      	bne.n	b7ba <_sercom_get_default_pad+0x1a>
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    b7ca:	2901      	cmp	r1, #1
    b7cc:	d017      	beq.n	b7fe <_sercom_get_default_pad+0x5e>
    b7ce:	2900      	cmp	r1, #0
    b7d0:	d05d      	beq.n	b88e <_sercom_get_default_pad+0xee>
    b7d2:	2902      	cmp	r1, #2
    b7d4:	d015      	beq.n	b802 <_sercom_get_default_pad+0x62>
    b7d6:	2903      	cmp	r1, #3
    b7d8:	d015      	beq.n	b806 <_sercom_get_default_pad+0x66>
	return 0;
    b7da:	2000      	movs	r0, #0
    b7dc:	e7ee      	b.n	b7bc <_sercom_get_default_pad+0x1c>
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    b7de:	2901      	cmp	r1, #1
    b7e0:	d007      	beq.n	b7f2 <_sercom_get_default_pad+0x52>
    b7e2:	2900      	cmp	r1, #0
    b7e4:	d051      	beq.n	b88a <_sercom_get_default_pad+0xea>
    b7e6:	2902      	cmp	r1, #2
    b7e8:	d005      	beq.n	b7f6 <_sercom_get_default_pad+0x56>
    b7ea:	2903      	cmp	r1, #3
    b7ec:	d005      	beq.n	b7fa <_sercom_get_default_pad+0x5a>
	return 0;
    b7ee:	2000      	movs	r0, #0
    b7f0:	e7e4      	b.n	b7bc <_sercom_get_default_pad+0x1c>
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    b7f2:	4832      	ldr	r0, [pc, #200]	; (b8bc <_sercom_get_default_pad+0x11c>)
    b7f4:	e7e2      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b7f6:	4832      	ldr	r0, [pc, #200]	; (b8c0 <_sercom_get_default_pad+0x120>)
    b7f8:	e7e0      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b7fa:	4832      	ldr	r0, [pc, #200]	; (b8c4 <_sercom_get_default_pad+0x124>)
    b7fc:	e7de      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b7fe:	4832      	ldr	r0, [pc, #200]	; (b8c8 <_sercom_get_default_pad+0x128>)
    b800:	e7dc      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b802:	4832      	ldr	r0, [pc, #200]	; (b8cc <_sercom_get_default_pad+0x12c>)
    b804:	e7da      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b806:	4832      	ldr	r0, [pc, #200]	; (b8d0 <_sercom_get_default_pad+0x130>)
    b808:	e7d8      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b80a:	2901      	cmp	r1, #1
    b80c:	d007      	beq.n	b81e <_sercom_get_default_pad+0x7e>
    b80e:	2900      	cmp	r1, #0
    b810:	d03f      	beq.n	b892 <_sercom_get_default_pad+0xf2>
    b812:	2902      	cmp	r1, #2
    b814:	d005      	beq.n	b822 <_sercom_get_default_pad+0x82>
    b816:	2903      	cmp	r1, #3
    b818:	d005      	beq.n	b826 <_sercom_get_default_pad+0x86>
	return 0;
    b81a:	2000      	movs	r0, #0
    b81c:	e7ce      	b.n	b7bc <_sercom_get_default_pad+0x1c>
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    b81e:	482d      	ldr	r0, [pc, #180]	; (b8d4 <_sercom_get_default_pad+0x134>)
    b820:	e7cc      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b822:	482d      	ldr	r0, [pc, #180]	; (b8d8 <_sercom_get_default_pad+0x138>)
    b824:	e7ca      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b826:	482d      	ldr	r0, [pc, #180]	; (b8dc <_sercom_get_default_pad+0x13c>)
    b828:	e7c8      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b82a:	2901      	cmp	r1, #1
    b82c:	d007      	beq.n	b83e <_sercom_get_default_pad+0x9e>
    b82e:	2900      	cmp	r1, #0
    b830:	d031      	beq.n	b896 <_sercom_get_default_pad+0xf6>
    b832:	2902      	cmp	r1, #2
    b834:	d005      	beq.n	b842 <_sercom_get_default_pad+0xa2>
    b836:	2903      	cmp	r1, #3
    b838:	d005      	beq.n	b846 <_sercom_get_default_pad+0xa6>
	return 0;
    b83a:	2000      	movs	r0, #0
    b83c:	e7be      	b.n	b7bc <_sercom_get_default_pad+0x1c>
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    b83e:	4828      	ldr	r0, [pc, #160]	; (b8e0 <_sercom_get_default_pad+0x140>)
    b840:	e7bc      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b842:	4828      	ldr	r0, [pc, #160]	; (b8e4 <_sercom_get_default_pad+0x144>)
    b844:	e7ba      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b846:	4828      	ldr	r0, [pc, #160]	; (b8e8 <_sercom_get_default_pad+0x148>)
    b848:	e7b8      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b84a:	2901      	cmp	r1, #1
    b84c:	d007      	beq.n	b85e <_sercom_get_default_pad+0xbe>
    b84e:	2900      	cmp	r1, #0
    b850:	d023      	beq.n	b89a <_sercom_get_default_pad+0xfa>
    b852:	2902      	cmp	r1, #2
    b854:	d005      	beq.n	b862 <_sercom_get_default_pad+0xc2>
    b856:	2903      	cmp	r1, #3
    b858:	d005      	beq.n	b866 <_sercom_get_default_pad+0xc6>
	return 0;
    b85a:	2000      	movs	r0, #0
    b85c:	e7ae      	b.n	b7bc <_sercom_get_default_pad+0x1c>
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    b85e:	4823      	ldr	r0, [pc, #140]	; (b8ec <_sercom_get_default_pad+0x14c>)
    b860:	e7ac      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b862:	4823      	ldr	r0, [pc, #140]	; (b8f0 <_sercom_get_default_pad+0x150>)
    b864:	e7aa      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b866:	4823      	ldr	r0, [pc, #140]	; (b8f4 <_sercom_get_default_pad+0x154>)
    b868:	e7a8      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b86a:	2901      	cmp	r1, #1
    b86c:	d007      	beq.n	b87e <_sercom_get_default_pad+0xde>
    b86e:	2900      	cmp	r1, #0
    b870:	d015      	beq.n	b89e <_sercom_get_default_pad+0xfe>
    b872:	2902      	cmp	r1, #2
    b874:	d005      	beq.n	b882 <_sercom_get_default_pad+0xe2>
    b876:	2903      	cmp	r1, #3
    b878:	d005      	beq.n	b886 <_sercom_get_default_pad+0xe6>
	return 0;
    b87a:	2000      	movs	r0, #0
    b87c:	e79e      	b.n	b7bc <_sercom_get_default_pad+0x1c>
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    b87e:	481e      	ldr	r0, [pc, #120]	; (b8f8 <_sercom_get_default_pad+0x158>)
    b880:	e79c      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b882:	481e      	ldr	r0, [pc, #120]	; (b8fc <_sercom_get_default_pad+0x15c>)
    b884:	e79a      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b886:	481e      	ldr	r0, [pc, #120]	; (b900 <_sercom_get_default_pad+0x160>)
    b888:	e798      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b88a:	481e      	ldr	r0, [pc, #120]	; (b904 <_sercom_get_default_pad+0x164>)
    b88c:	e796      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b88e:	2003      	movs	r0, #3
    b890:	e794      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b892:	481d      	ldr	r0, [pc, #116]	; (b908 <_sercom_get_default_pad+0x168>)
    b894:	e792      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b896:	481d      	ldr	r0, [pc, #116]	; (b90c <_sercom_get_default_pad+0x16c>)
    b898:	e790      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b89a:	481d      	ldr	r0, [pc, #116]	; (b910 <_sercom_get_default_pad+0x170>)
    b89c:	e78e      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b89e:	481d      	ldr	r0, [pc, #116]	; (b914 <_sercom_get_default_pad+0x174>)
    b8a0:	e78c      	b.n	b7bc <_sercom_get_default_pad+0x1c>
    b8a2:	46c0      	nop			; (mov r8, r8)
    b8a4:	42001000 	.word	0x42001000
    b8a8:	42001800 	.word	0x42001800
    b8ac:	42001c00 	.word	0x42001c00
    b8b0:	42001400 	.word	0x42001400
    b8b4:	42000800 	.word	0x42000800
    b8b8:	42000c00 	.word	0x42000c00
    b8bc:	00050003 	.word	0x00050003
    b8c0:	00060003 	.word	0x00060003
    b8c4:	00070003 	.word	0x00070003
    b8c8:	00010003 	.word	0x00010003
    b8cc:	001e0003 	.word	0x001e0003
    b8d0:	001f0003 	.word	0x001f0003
    b8d4:	00090003 	.word	0x00090003
    b8d8:	000a0003 	.word	0x000a0003
    b8dc:	000b0003 	.word	0x000b0003
    b8e0:	00110003 	.word	0x00110003
    b8e4:	00120003 	.word	0x00120003
    b8e8:	00130003 	.word	0x00130003
    b8ec:	000d0003 	.word	0x000d0003
    b8f0:	000e0003 	.word	0x000e0003
    b8f4:	000f0003 	.word	0x000f0003
    b8f8:	00170003 	.word	0x00170003
    b8fc:	00180003 	.word	0x00180003
    b900:	00190003 	.word	0x00190003
    b904:	00040003 	.word	0x00040003
    b908:	00080003 	.word	0x00080003
    b90c:	00100003 	.word	0x00100003
    b910:	000c0003 	.word	0x000c0003
    b914:	00160003 	.word	0x00160003

0000b918 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    b918:	b530      	push	{r4, r5, lr}
    b91a:	b087      	sub	sp, #28
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    b91c:	4b0b      	ldr	r3, [pc, #44]	; (b94c <_sercom_get_sercom_inst_index+0x34>)
    b91e:	466a      	mov	r2, sp
    b920:	cb32      	ldmia	r3!, {r1, r4, r5}
    b922:	c232      	stmia	r2!, {r1, r4, r5}
    b924:	cb32      	ldmia	r3!, {r1, r4, r5}
    b926:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    b928:	9b00      	ldr	r3, [sp, #0]
    b92a:	4283      	cmp	r3, r0
    b92c:	d00b      	beq.n	b946 <_sercom_get_sercom_inst_index+0x2e>
    b92e:	2301      	movs	r3, #1
    b930:	009a      	lsls	r2, r3, #2
    b932:	4669      	mov	r1, sp
    b934:	5852      	ldr	r2, [r2, r1]
    b936:	4282      	cmp	r2, r0
    b938:	d006      	beq.n	b948 <_sercom_get_sercom_inst_index+0x30>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    b93a:	3301      	adds	r3, #1
    b93c:	2b06      	cmp	r3, #6
    b93e:	d1f7      	bne.n	b930 <_sercom_get_sercom_inst_index+0x18>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
    b940:	2000      	movs	r0, #0
}
    b942:	b007      	add	sp, #28
    b944:	bd30      	pop	{r4, r5, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    b946:	2300      	movs	r3, #0
			return i;
    b948:	b2d8      	uxtb	r0, r3
    b94a:	e7fa      	b.n	b942 <_sercom_get_sercom_inst_index+0x2a>
    b94c:	0000d218 	.word	0x0000d218

0000b950 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
    b950:	4770      	bx	lr
	...

0000b954 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    b954:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    b956:	4b0a      	ldr	r3, [pc, #40]	; (b980 <_sercom_set_handler+0x2c>)
    b958:	781b      	ldrb	r3, [r3, #0]
    b95a:	2b00      	cmp	r3, #0
    b95c:	d10c      	bne.n	b978 <_sercom_set_handler+0x24>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    b95e:	4f09      	ldr	r7, [pc, #36]	; (b984 <_sercom_set_handler+0x30>)
    b960:	4e09      	ldr	r6, [pc, #36]	; (b988 <_sercom_set_handler+0x34>)
			_sercom_instances[i] = NULL;
    b962:	4d0a      	ldr	r5, [pc, #40]	; (b98c <_sercom_set_handler+0x38>)
    b964:	2400      	movs	r4, #0
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    b966:	51de      	str	r6, [r3, r7]
			_sercom_instances[i] = NULL;
    b968:	195a      	adds	r2, r3, r5
    b96a:	6014      	str	r4, [r2, #0]
    b96c:	3304      	adds	r3, #4
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    b96e:	2b18      	cmp	r3, #24
    b970:	d1f9      	bne.n	b966 <_sercom_set_handler+0x12>
		}

		_handler_table_initialized = true;
    b972:	2201      	movs	r2, #1
    b974:	4b02      	ldr	r3, [pc, #8]	; (b980 <_sercom_set_handler+0x2c>)
    b976:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
    b978:	0080      	lsls	r0, r0, #2
    b97a:	4b02      	ldr	r3, [pc, #8]	; (b984 <_sercom_set_handler+0x30>)
    b97c:	50c1      	str	r1, [r0, r3]
}
    b97e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b980:	20000102 	.word	0x20000102
    b984:	20000104 	.word	0x20000104
    b988:	0000b951 	.word	0x0000b951
    b98c:	20000584 	.word	0x20000584

0000b990 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
    b990:	b500      	push	{lr}
    b992:	b083      	sub	sp, #12
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    b994:	2309      	movs	r3, #9
    b996:	466a      	mov	r2, sp
    b998:	7013      	strb	r3, [r2, #0]
    b99a:	3301      	adds	r3, #1
    b99c:	7053      	strb	r3, [r2, #1]
    b99e:	3301      	adds	r3, #1
    b9a0:	7093      	strb	r3, [r2, #2]
    b9a2:	3301      	adds	r3, #1
    b9a4:	70d3      	strb	r3, [r2, #3]
    b9a6:	3301      	adds	r3, #1
    b9a8:	7113      	strb	r3, [r2, #4]
    b9aa:	3301      	adds	r3, #1
    b9ac:	7153      	strb	r3, [r2, #5]
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    b9ae:	4b03      	ldr	r3, [pc, #12]	; (b9bc <_sercom_get_interrupt_vector+0x2c>)
    b9b0:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    b9b2:	466b      	mov	r3, sp
    b9b4:	5618      	ldrsb	r0, [r3, r0]
}
    b9b6:	b003      	add	sp, #12
    b9b8:	bd00      	pop	{pc}
    b9ba:	46c0      	nop			; (mov r8, r8)
    b9bc:	0000b919 	.word	0x0000b919

0000b9c0 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    b9c0:	b510      	push	{r4, lr}
    b9c2:	4b02      	ldr	r3, [pc, #8]	; (b9cc <SERCOM0_Handler+0xc>)
    b9c4:	681b      	ldr	r3, [r3, #0]
    b9c6:	2000      	movs	r0, #0
    b9c8:	4798      	blx	r3
    b9ca:	bd10      	pop	{r4, pc}
    b9cc:	20000104 	.word	0x20000104

0000b9d0 <SERCOM1_Handler>:
    b9d0:	b510      	push	{r4, lr}
    b9d2:	4b02      	ldr	r3, [pc, #8]	; (b9dc <SERCOM1_Handler+0xc>)
    b9d4:	685b      	ldr	r3, [r3, #4]
    b9d6:	2001      	movs	r0, #1
    b9d8:	4798      	blx	r3
    b9da:	bd10      	pop	{r4, pc}
    b9dc:	20000104 	.word	0x20000104

0000b9e0 <SERCOM2_Handler>:
    b9e0:	b510      	push	{r4, lr}
    b9e2:	4b02      	ldr	r3, [pc, #8]	; (b9ec <SERCOM2_Handler+0xc>)
    b9e4:	689b      	ldr	r3, [r3, #8]
    b9e6:	2002      	movs	r0, #2
    b9e8:	4798      	blx	r3
    b9ea:	bd10      	pop	{r4, pc}
    b9ec:	20000104 	.word	0x20000104

0000b9f0 <SERCOM3_Handler>:
    b9f0:	b510      	push	{r4, lr}
    b9f2:	4b02      	ldr	r3, [pc, #8]	; (b9fc <SERCOM3_Handler+0xc>)
    b9f4:	68db      	ldr	r3, [r3, #12]
    b9f6:	2003      	movs	r0, #3
    b9f8:	4798      	blx	r3
    b9fa:	bd10      	pop	{r4, pc}
    b9fc:	20000104 	.word	0x20000104

0000ba00 <SERCOM4_Handler>:
    ba00:	b510      	push	{r4, lr}
    ba02:	4b02      	ldr	r3, [pc, #8]	; (ba0c <SERCOM4_Handler+0xc>)
    ba04:	691b      	ldr	r3, [r3, #16]
    ba06:	2004      	movs	r0, #4
    ba08:	4798      	blx	r3
    ba0a:	bd10      	pop	{r4, pc}
    ba0c:	20000104 	.word	0x20000104

0000ba10 <SERCOM5_Handler>:
    ba10:	b510      	push	{r4, lr}
    ba12:	4b02      	ldr	r3, [pc, #8]	; (ba1c <SERCOM5_Handler+0xc>)
    ba14:	695b      	ldr	r3, [r3, #20]
    ba16:	2005      	movs	r0, #5
    ba18:	4798      	blx	r3
    ba1a:	bd10      	pop	{r4, pc}
    ba1c:	20000104 	.word	0x20000104

0000ba20 <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
    ba20:	b5f0      	push	{r4, r5, r6, r7, lr}
    ba22:	b08b      	sub	sp, #44	; 0x2c
    ba24:	0005      	movs	r5, r0
    ba26:	000c      	movs	r4, r1
    ba28:	0016      	movs	r6, r2
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    ba2a:	6029      	str	r1, [r5, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    ba2c:	680b      	ldr	r3, [r1, #0]
#  if SPI_CALLBACK_MODE == false
		/* Check if config is valid */
		return _spi_check_config(module, config);
#  else
		return STATUS_ERR_DENIED;
    ba2e:	201c      	movs	r0, #28
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    ba30:	079b      	lsls	r3, r3, #30
    ba32:	d501      	bpl.n	ba38 <spi_init+0x18>
	_sercom_instances[instance_index] = module;
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
}
    ba34:	b00b      	add	sp, #44	; 0x2c
    ba36:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    ba38:	680b      	ldr	r3, [r1, #0]
		return STATUS_BUSY;
    ba3a:	3817      	subs	r0, #23
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    ba3c:	07db      	lsls	r3, r3, #31
    ba3e:	d4f9      	bmi.n	ba34 <spi_init+0x14>
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    ba40:	0008      	movs	r0, r1
    ba42:	4b60      	ldr	r3, [pc, #384]	; (bbc4 <spi_init+0x1a4>)
    ba44:	4798      	blx	r3
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    ba46:	4a60      	ldr	r2, [pc, #384]	; (bbc8 <spi_init+0x1a8>)
    ba48:	6a11      	ldr	r1, [r2, #32]
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    ba4a:	1c87      	adds	r7, r0, #2
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    ba4c:	2301      	movs	r3, #1
    ba4e:	40bb      	lsls	r3, r7
    ba50:	430b      	orrs	r3, r1
    ba52:	6213      	str	r3, [r2, #32]
	gclk_chan_conf.source_generator = config->generator_source;
    ba54:	a909      	add	r1, sp, #36	; 0x24
    ba56:	2724      	movs	r7, #36	; 0x24
    ba58:	5df3      	ldrb	r3, [r6, r7]
    ba5a:	700b      	strb	r3, [r1, #0]
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    ba5c:	3014      	adds	r0, #20
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    ba5e:	b2c3      	uxtb	r3, r0
    ba60:	9301      	str	r3, [sp, #4]
    ba62:	0018      	movs	r0, r3
    ba64:	4b59      	ldr	r3, [pc, #356]	; (bbcc <spi_init+0x1ac>)
    ba66:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    ba68:	9801      	ldr	r0, [sp, #4]
    ba6a:	4b59      	ldr	r3, [pc, #356]	; (bbd0 <spi_init+0x1b0>)
    ba6c:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    ba6e:	5df0      	ldrb	r0, [r6, r7]
    ba70:	2100      	movs	r1, #0
    ba72:	4b58      	ldr	r3, [pc, #352]	; (bbd4 <spi_init+0x1b4>)
    ba74:	4798      	blx	r3
	if (config->mode == SPI_MODE_MASTER) {
    ba76:	7833      	ldrb	r3, [r6, #0]
    ba78:	2b01      	cmp	r3, #1
    ba7a:	d038      	beq.n	baee <spi_init+0xce>
    ba7c:	002b      	movs	r3, r5
    ba7e:	330c      	adds	r3, #12
    ba80:	0029      	movs	r1, r5
    ba82:	3128      	adds	r1, #40	; 0x28
		module->callback[i]        = NULL;
    ba84:	2200      	movs	r2, #0
    ba86:	c304      	stmia	r3!, {r2}
	for (i = 0; i < SPI_CALLBACK_N; i++) {
    ba88:	428b      	cmp	r3, r1
    ba8a:	d1fc      	bne.n	ba86 <spi_init+0x66>
	module->tx_buffer_ptr              = NULL;
    ba8c:	2300      	movs	r3, #0
    ba8e:	62eb      	str	r3, [r5, #44]	; 0x2c
	module->rx_buffer_ptr              = NULL;
    ba90:	62ab      	str	r3, [r5, #40]	; 0x28
	module->remaining_tx_buffer_length = 0x0000;
    ba92:	2400      	movs	r4, #0
    ba94:	86ab      	strh	r3, [r5, #52]	; 0x34
	module->remaining_rx_buffer_length = 0x0000;
    ba96:	862b      	strh	r3, [r5, #48]	; 0x30
	module->registered_callback        = 0x00;
    ba98:	3336      	adds	r3, #54	; 0x36
    ba9a:	54ec      	strb	r4, [r5, r3]
	module->enabled_callback           = 0x00;
    ba9c:	3301      	adds	r3, #1
    ba9e:	54ec      	strb	r4, [r5, r3]
	module->status                     = STATUS_OK;
    baa0:	3301      	adds	r3, #1
    baa2:	54ec      	strb	r4, [r5, r3]
	module->dir                        = SPI_DIRECTION_IDLE;
    baa4:	3b35      	subs	r3, #53	; 0x35
    baa6:	726b      	strb	r3, [r5, #9]
	module->locked                     = false;
    baa8:	712c      	strb	r4, [r5, #4]
	instance_index = _sercom_get_sercom_inst_index(module->hw);
    baaa:	6828      	ldr	r0, [r5, #0]
    baac:	4b45      	ldr	r3, [pc, #276]	; (bbc4 <spi_init+0x1a4>)
    baae:	4798      	blx	r3
    bab0:	0007      	movs	r7, r0
	_sercom_set_handler(instance_index, _spi_interrupt_handler);
    bab2:	4949      	ldr	r1, [pc, #292]	; (bbd8 <spi_init+0x1b8>)
    bab4:	4b49      	ldr	r3, [pc, #292]	; (bbdc <spi_init+0x1bc>)
    bab6:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    bab8:	00bf      	lsls	r7, r7, #2
    baba:	4b49      	ldr	r3, [pc, #292]	; (bbe0 <spi_init+0x1c0>)
    babc:	50fd      	str	r5, [r7, r3]
	SercomSpi *const spi_module = &(module->hw->SPI);
    babe:	682f      	ldr	r7, [r5, #0]
    bac0:	ab04      	add	r3, sp, #16
    bac2:	2280      	movs	r2, #128	; 0x80
    bac4:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    bac6:	705c      	strb	r4, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    bac8:	3a7f      	subs	r2, #127	; 0x7f
    baca:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    bacc:	70dc      	strb	r4, [r3, #3]
	if(config->mode == SPI_MODE_SLAVE) {
    bace:	7833      	ldrb	r3, [r6, #0]
    bad0:	2b00      	cmp	r3, #0
    bad2:	d102      	bne.n	bada <spi_init+0xba>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    bad4:	2200      	movs	r2, #0
    bad6:	ab04      	add	r3, sp, #16
    bad8:	709a      	strb	r2, [r3, #2]
	uint32_t pad_pinmuxes[] = {
    bada:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    badc:	9305      	str	r3, [sp, #20]
    bade:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    bae0:	9306      	str	r3, [sp, #24]
    bae2:	6b33      	ldr	r3, [r6, #48]	; 0x30
    bae4:	9307      	str	r3, [sp, #28]
    bae6:	6b73      	ldr	r3, [r6, #52]	; 0x34
    bae8:	9308      	str	r3, [sp, #32]
    baea:	2400      	movs	r4, #0
    baec:	e00b      	b.n	bb06 <spi_init+0xe6>
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
    baee:	6823      	ldr	r3, [r4, #0]
    baf0:	220c      	movs	r2, #12
    baf2:	4313      	orrs	r3, r2
    baf4:	6023      	str	r3, [r4, #0]
    baf6:	e7c1      	b.n	ba7c <spi_init+0x5c>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    baf8:	0038      	movs	r0, r7
    bafa:	4b3a      	ldr	r3, [pc, #232]	; (bbe4 <spi_init+0x1c4>)
    bafc:	4798      	blx	r3
    bafe:	e00a      	b.n	bb16 <spi_init+0xf6>
    bb00:	3401      	adds	r4, #1
	for (uint8_t pad = 0; pad < 4; pad++) {
    bb02:	2c04      	cmp	r4, #4
    bb04:	d010      	beq.n	bb28 <spi_init+0x108>
    bb06:	b2e1      	uxtb	r1, r4
		uint32_t current_pinmux = pad_pinmuxes[pad];
    bb08:	00a3      	lsls	r3, r4, #2
    bb0a:	aa02      	add	r2, sp, #8
    bb0c:	200c      	movs	r0, #12
    bb0e:	1812      	adds	r2, r2, r0
    bb10:	58d0      	ldr	r0, [r2, r3]
		if (current_pinmux == PINMUX_DEFAULT) {
    bb12:	2800      	cmp	r0, #0
    bb14:	d0f0      	beq.n	baf8 <spi_init+0xd8>
		if (current_pinmux != PINMUX_UNUSED) {
    bb16:	1c43      	adds	r3, r0, #1
    bb18:	d0f2      	beq.n	bb00 <spi_init+0xe0>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    bb1a:	a904      	add	r1, sp, #16
    bb1c:	7008      	strb	r0, [r1, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    bb1e:	0c00      	lsrs	r0, r0, #16
    bb20:	b2c0      	uxtb	r0, r0
    bb22:	4b31      	ldr	r3, [pc, #196]	; (bbe8 <spi_init+0x1c8>)
    bb24:	4798      	blx	r3
    bb26:	e7eb      	b.n	bb00 <spi_init+0xe0>
	module->mode             = config->mode;
    bb28:	7833      	ldrb	r3, [r6, #0]
    bb2a:	716b      	strb	r3, [r5, #5]
	module->character_size   = config->character_size;
    bb2c:	7c33      	ldrb	r3, [r6, #16]
    bb2e:	71ab      	strb	r3, [r5, #6]
	module->receiver_enabled = config->receiver_enable;
    bb30:	7cb3      	ldrb	r3, [r6, #18]
    bb32:	71eb      	strb	r3, [r5, #7]
	module->master_slave_select_enable = config->master_slave_select_enable;
    bb34:	7d33      	ldrb	r3, [r6, #20]
    bb36:	722b      	strb	r3, [r5, #8]
	uint16_t baud = 0;
    bb38:	2200      	movs	r2, #0
    bb3a:	ab02      	add	r3, sp, #8
    bb3c:	80da      	strh	r2, [r3, #6]
	if (config->mode == SPI_MODE_MASTER) {
    bb3e:	7833      	ldrb	r3, [r6, #0]
    bb40:	2b01      	cmp	r3, #1
    bb42:	d028      	beq.n	bb96 <spi_init+0x176>
	ctrla |= config->transfer_mode;
    bb44:	6873      	ldr	r3, [r6, #4]
    bb46:	68b2      	ldr	r2, [r6, #8]
    bb48:	4313      	orrs	r3, r2
	ctrla |= config->mux_setting;
    bb4a:	68f2      	ldr	r2, [r6, #12]
    bb4c:	4313      	orrs	r3, r2
	ctrlb |= config->character_size;
    bb4e:	7c31      	ldrb	r1, [r6, #16]
	if (config->run_in_standby || system_is_debugger_present()) {
    bb50:	7c72      	ldrb	r2, [r6, #17]
    bb52:	2a00      	cmp	r2, #0
    bb54:	d103      	bne.n	bb5e <spi_init+0x13e>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    bb56:	4a25      	ldr	r2, [pc, #148]	; (bbec <spi_init+0x1cc>)
    bb58:	7892      	ldrb	r2, [r2, #2]
    bb5a:	0792      	lsls	r2, r2, #30
    bb5c:	d501      	bpl.n	bb62 <spi_init+0x142>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
    bb5e:	2280      	movs	r2, #128	; 0x80
    bb60:	4313      	orrs	r3, r2
	if (config->receiver_enable) {
    bb62:	7cb2      	ldrb	r2, [r6, #18]
    bb64:	2a00      	cmp	r2, #0
    bb66:	d002      	beq.n	bb6e <spi_init+0x14e>
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
    bb68:	2280      	movs	r2, #128	; 0x80
    bb6a:	0292      	lsls	r2, r2, #10
    bb6c:	4311      	orrs	r1, r2
	if (config->select_slave_low_detect_enable) {
    bb6e:	7cf2      	ldrb	r2, [r6, #19]
    bb70:	2a00      	cmp	r2, #0
    bb72:	d002      	beq.n	bb7a <spi_init+0x15a>
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
    bb74:	2280      	movs	r2, #128	; 0x80
    bb76:	0092      	lsls	r2, r2, #2
    bb78:	4311      	orrs	r1, r2
	if (config->master_slave_select_enable) {
    bb7a:	7d32      	ldrb	r2, [r6, #20]
    bb7c:	2a00      	cmp	r2, #0
    bb7e:	d002      	beq.n	bb86 <spi_init+0x166>
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
    bb80:	2280      	movs	r2, #128	; 0x80
    bb82:	0192      	lsls	r2, r2, #6
    bb84:	4311      	orrs	r1, r2
	spi_module->CTRLA.reg |= ctrla;
    bb86:	683a      	ldr	r2, [r7, #0]
    bb88:	4313      	orrs	r3, r2
    bb8a:	603b      	str	r3, [r7, #0]
	spi_module->CTRLB.reg |= ctrlb;
    bb8c:	687b      	ldr	r3, [r7, #4]
    bb8e:	430b      	orrs	r3, r1
    bb90:	607b      	str	r3, [r7, #4]
	return STATUS_OK;
    bb92:	2000      	movs	r0, #0
    bb94:	e74e      	b.n	ba34 <spi_init+0x14>
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    bb96:	6828      	ldr	r0, [r5, #0]
    bb98:	4b0a      	ldr	r3, [pc, #40]	; (bbc4 <spi_init+0x1a4>)
    bb9a:	4798      	blx	r3
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    bb9c:	3014      	adds	r0, #20
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    bb9e:	b2c0      	uxtb	r0, r0
    bba0:	4b13      	ldr	r3, [pc, #76]	; (bbf0 <spi_init+0x1d0>)
    bba2:	4798      	blx	r3
    bba4:	0001      	movs	r1, r0
		enum status_code error_code = _sercom_get_sync_baud_val(
    bba6:	ab02      	add	r3, sp, #8
    bba8:	1d9a      	adds	r2, r3, #6
    bbaa:	69b0      	ldr	r0, [r6, #24]
    bbac:	4b11      	ldr	r3, [pc, #68]	; (bbf4 <spi_init+0x1d4>)
    bbae:	4798      	blx	r3
    bbb0:	0003      	movs	r3, r0
			return STATUS_ERR_INVALID_ARG;
    bbb2:	2017      	movs	r0, #23
		if (error_code != STATUS_OK) {
    bbb4:	2b00      	cmp	r3, #0
    bbb6:	d000      	beq.n	bbba <spi_init+0x19a>
    bbb8:	e73c      	b.n	ba34 <spi_init+0x14>
		spi_module->BAUD.reg = (uint8_t)baud;
    bbba:	ab02      	add	r3, sp, #8
    bbbc:	3306      	adds	r3, #6
    bbbe:	781b      	ldrb	r3, [r3, #0]
    bbc0:	733b      	strb	r3, [r7, #12]
    bbc2:	e7bf      	b.n	bb44 <spi_init+0x124>
    bbc4:	0000b919 	.word	0x0000b919
    bbc8:	40000400 	.word	0x40000400
    bbcc:	0000c9dd 	.word	0x0000c9dd
    bbd0:	0000c951 	.word	0x0000c951
    bbd4:	0000b755 	.word	0x0000b755
    bbd8:	0000bbf9 	.word	0x0000bbf9
    bbdc:	0000b955 	.word	0x0000b955
    bbe0:	20000584 	.word	0x20000584
    bbe4:	0000b7a1 	.word	0x0000b7a1
    bbe8:	0000cad5 	.word	0x0000cad5
    bbec:	41002000 	.word	0x41002000
    bbf0:	0000c9f9 	.word	0x0000c9f9
    bbf4:	0000b697 	.word	0x0000b697

0000bbf8 <_spi_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
    bbf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Get device instance from the look-up table */
	struct spi_module *module
    bbfa:	0080      	lsls	r0, r0, #2
    bbfc:	4b70      	ldr	r3, [pc, #448]	; (bdc0 <_spi_interrupt_handler+0x1c8>)
    bbfe:	58c4      	ldr	r4, [r0, r3]
		= (struct spi_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    bc00:	6826      	ldr	r6, [r4, #0]

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
			module->enabled_callback & module->registered_callback;
    bc02:	2337      	movs	r3, #55	; 0x37
	uint8_t callback_mask =
    bc04:	5ce7      	ldrb	r7, [r4, r3]
    bc06:	2236      	movs	r2, #54	; 0x36
    bc08:	5ca2      	ldrb	r2, [r4, r2]
    bc0a:	4017      	ands	r7, r2

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = spi_hw->INTFLAG.reg;
    bc0c:	7e33      	ldrb	r3, [r6, #24]
	interrupt_status &= spi_hw->INTENSET.reg;
    bc0e:	7db5      	ldrb	r5, [r6, #22]
    bc10:	401d      	ands	r5, r3

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
    bc12:	07eb      	lsls	r3, r5, #31
    bc14:	d502      	bpl.n	bc1c <_spi_interrupt_handler+0x24>
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    bc16:	7963      	ldrb	r3, [r4, #5]
    bc18:	2b01      	cmp	r3, #1
    bc1a:	d01e      	beq.n	bc5a <_spi_interrupt_handler+0x62>
			}
		}
	}

	/* Receive complete interrupt*/
	if (interrupt_status & SPI_INTERRUPT_FLAG_RX_COMPLETE) {
    bc1c:	076b      	lsls	r3, r5, #29
    bc1e:	d511      	bpl.n	bc44 <_spi_interrupt_handler+0x4c>
		/* Check for overflow */
		if (spi_hw->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    bc20:	8b73      	ldrh	r3, [r6, #26]
    bc22:	075b      	lsls	r3, r3, #29
    bc24:	d55a      	bpl.n	bcdc <_spi_interrupt_handler+0xe4>
			if (module->dir != SPI_DIRECTION_WRITE) {
    bc26:	7a63      	ldrb	r3, [r4, #9]
    bc28:	2b01      	cmp	r3, #1
    bc2a:	d008      	beq.n	bc3e <_spi_interrupt_handler+0x46>
				/* Store the error code */
				module->status = STATUS_ERR_OVERFLOW;
    bc2c:	221e      	movs	r2, #30
    bc2e:	2338      	movs	r3, #56	; 0x38
    bc30:	54e2      	strb	r2, [r4, r3]

				/* End transaction */
				module->dir = SPI_DIRECTION_IDLE;
    bc32:	3b35      	subs	r3, #53	; 0x35
    bc34:	7263      	strb	r3, [r4, #9]

				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE |
    bc36:	3302      	adds	r3, #2
    bc38:	7533      	strb	r3, [r6, #20]
						SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
				/* Run callback if registered and enabled */
				if (callback_mask & (1 << SPI_CALLBACK_ERROR)) {
    bc3a:	073b      	lsls	r3, r7, #28
    bc3c:	d44a      	bmi.n	bcd4 <_spi_interrupt_handler+0xdc>
					(module->callback[SPI_CALLBACK_ERROR])(module);
				}
			}
			/* Flush */
			uint16_t flush = spi_hw->DATA.reg;
    bc3e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
			UNUSED(flush);
			/* Clear overflow flag */
			spi_hw->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    bc40:	2304      	movs	r3, #4
    bc42:	8373      	strh	r3, [r6, #26]
			}
		}
	}

	/* Transmit complete */
	if (interrupt_status & SPI_INTERRUPT_FLAG_TX_COMPLETE) {
    bc44:	07ab      	lsls	r3, r5, #30
    bc46:	d503      	bpl.n	bc50 <_spi_interrupt_handler+0x58>
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    bc48:	7963      	ldrb	r3, [r4, #5]
    bc4a:	2b01      	cmp	r3, #1
    bc4c:	d100      	bne.n	bc50 <_spi_interrupt_handler+0x58>
    bc4e:	e097      	b.n	bd80 <_spi_interrupt_handler+0x188>
#  endif
#  endif

#  ifdef FEATURE_SPI_ERROR_INTERRUPT
	/* When combined error happen */
	if (interrupt_status & SPI_INTERRUPT_FLAG_COMBINED_ERROR) {
    bc50:	b26d      	sxtb	r5, r5
    bc52:	2d00      	cmp	r5, #0
    bc54:	da00      	bge.n	bc58 <_spi_interrupt_handler+0x60>
    bc56:	e0a9      	b.n	bdac <_spi_interrupt_handler+0x1b4>
		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
		}
	}
#  endif
}
    bc58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			(module->dir == SPI_DIRECTION_READ)) {
    bc5a:	7a63      	ldrb	r3, [r4, #9]
		if ((module->mode == SPI_MODE_MASTER) &&
    bc5c:	2b00      	cmp	r3, #0
    bc5e:	d022      	beq.n	bca6 <_spi_interrupt_handler+0xae>
			(module->dir != SPI_DIRECTION_READ))
    bc60:	7a63      	ldrb	r3, [r4, #9]
		|| ((module->mode == SPI_MODE_MASTER) &&
    bc62:	2b00      	cmp	r3, #0
    bc64:	d0da      	beq.n	bc1c <_spi_interrupt_handler+0x24>
	SercomSpi *const spi_hw = &(module->hw->SPI);
    bc66:	6821      	ldr	r1, [r4, #0]
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    bc68:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    bc6a:	7813      	ldrb	r3, [r2, #0]
    bc6c:	b2db      	uxtb	r3, r3
	(module->tx_buffer_ptr)++;
    bc6e:	1c50      	adds	r0, r2, #1
    bc70:	62e0      	str	r0, [r4, #44]	; 0x2c
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    bc72:	79a0      	ldrb	r0, [r4, #6]
    bc74:	2801      	cmp	r0, #1
    bc76:	d027      	beq.n	bcc8 <_spi_interrupt_handler+0xd0>
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    bc78:	b29b      	uxth	r3, r3
	spi_hw->DATA.reg = data_to_send & SERCOM_SPI_DATA_MASK;
    bc7a:	05db      	lsls	r3, r3, #23
    bc7c:	0ddb      	lsrs	r3, r3, #23
    bc7e:	628b      	str	r3, [r1, #40]	; 0x28
	(module->remaining_tx_buffer_length)--;
    bc80:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    bc82:	3b01      	subs	r3, #1
    bc84:	b29b      	uxth	r3, r3
    bc86:	86a3      	strh	r3, [r4, #52]	; 0x34
			if (module->remaining_tx_buffer_length == 0) {
    bc88:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    bc8a:	b29b      	uxth	r3, r3
    bc8c:	2b00      	cmp	r3, #0
    bc8e:	d1c5      	bne.n	bc1c <_spi_interrupt_handler+0x24>
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    bc90:	3301      	adds	r3, #1
    bc92:	7533      	strb	r3, [r6, #20]
				if (module->dir == SPI_DIRECTION_WRITE &&
    bc94:	7a63      	ldrb	r3, [r4, #9]
    bc96:	2b01      	cmp	r3, #1
    bc98:	d1c0      	bne.n	bc1c <_spi_interrupt_handler+0x24>
    bc9a:	79e3      	ldrb	r3, [r4, #7]
    bc9c:	2b00      	cmp	r3, #0
    bc9e:	d1bd      	bne.n	bc1c <_spi_interrupt_handler+0x24>
					spi_hw->INTENSET.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    bca0:	3302      	adds	r3, #2
    bca2:	75b3      	strb	r3, [r6, #22]
    bca4:	e7ba      	b.n	bc1c <_spi_interrupt_handler+0x24>
	spi_hw->DATA.reg = dummy_write;
    bca6:	4b47      	ldr	r3, [pc, #284]	; (bdc4 <_spi_interrupt_handler+0x1cc>)
    bca8:	881b      	ldrh	r3, [r3, #0]
    bcaa:	62b3      	str	r3, [r6, #40]	; 0x28
	module->remaining_dummy_buffer_length--;
    bcac:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    bcae:	3b01      	subs	r3, #1
    bcb0:	b29b      	uxth	r3, r3
    bcb2:	8663      	strh	r3, [r4, #50]	; 0x32
			if (module->remaining_dummy_buffer_length == 0) {
    bcb4:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    bcb6:	b29b      	uxth	r3, r3
    bcb8:	2b00      	cmp	r3, #0
    bcba:	d101      	bne.n	bcc0 <_spi_interrupt_handler+0xc8>
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    bcbc:	3301      	adds	r3, #1
    bcbe:	7533      	strb	r3, [r6, #20]
		if (0
    bcc0:	7963      	ldrb	r3, [r4, #5]
    bcc2:	2b01      	cmp	r3, #1
    bcc4:	d0cc      	beq.n	bc60 <_spi_interrupt_handler+0x68>
    bcc6:	e7a9      	b.n	bc1c <_spi_interrupt_handler+0x24>
		data_to_send |= ((*(module->tx_buffer_ptr)) << 8);
    bcc8:	7850      	ldrb	r0, [r2, #1]
    bcca:	0200      	lsls	r0, r0, #8
    bccc:	4303      	orrs	r3, r0
		(module->tx_buffer_ptr)++;
    bcce:	3202      	adds	r2, #2
    bcd0:	62e2      	str	r2, [r4, #44]	; 0x2c
    bcd2:	e7d2      	b.n	bc7a <_spi_interrupt_handler+0x82>
					(module->callback[SPI_CALLBACK_ERROR])(module);
    bcd4:	0020      	movs	r0, r4
    bcd6:	69a3      	ldr	r3, [r4, #24]
    bcd8:	4798      	blx	r3
    bcda:	e7b0      	b.n	bc3e <_spi_interrupt_handler+0x46>
			if (module->dir == SPI_DIRECTION_WRITE) {
    bcdc:	7a63      	ldrb	r3, [r4, #9]
    bcde:	2b01      	cmp	r3, #1
    bce0:	d028      	beq.n	bd34 <_spi_interrupt_handler+0x13c>
	SercomSpi *const spi_hw = &(module->hw->SPI);
    bce2:	6823      	ldr	r3, [r4, #0]
	uint16_t received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
    bce4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    bce6:	05db      	lsls	r3, r3, #23
    bce8:	0ddb      	lsrs	r3, r3, #23
	*(module->rx_buffer_ptr) = received_data;
    bcea:	b2da      	uxtb	r2, r3
    bcec:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    bcee:	700a      	strb	r2, [r1, #0]
	module->rx_buffer_ptr += 1;
    bcf0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    bcf2:	1c51      	adds	r1, r2, #1
    bcf4:	62a1      	str	r1, [r4, #40]	; 0x28
	if(module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    bcf6:	79a1      	ldrb	r1, [r4, #6]
    bcf8:	2901      	cmp	r1, #1
    bcfa:	d034      	beq.n	bd66 <_spi_interrupt_handler+0x16e>
	module->remaining_rx_buffer_length--;
    bcfc:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    bcfe:	3b01      	subs	r3, #1
    bd00:	b29b      	uxth	r3, r3
    bd02:	8623      	strh	r3, [r4, #48]	; 0x30
				if (module->remaining_rx_buffer_length == 0) {
    bd04:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    bd06:	b29b      	uxth	r3, r3
    bd08:	2b00      	cmp	r3, #0
    bd0a:	d000      	beq.n	bd0e <_spi_interrupt_handler+0x116>
    bd0c:	e79a      	b.n	bc44 <_spi_interrupt_handler+0x4c>
					module->status = STATUS_OK;
    bd0e:	2200      	movs	r2, #0
    bd10:	3338      	adds	r3, #56	; 0x38
    bd12:	54e2      	strb	r2, [r4, r3]
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    bd14:	3b34      	subs	r3, #52	; 0x34
    bd16:	7533      	strb	r3, [r6, #20]
					if(module->dir == SPI_DIRECTION_BOTH) {
    bd18:	7a63      	ldrb	r3, [r4, #9]
    bd1a:	2b02      	cmp	r3, #2
    bd1c:	d029      	beq.n	bd72 <_spi_interrupt_handler+0x17a>
					} else if (module->dir == SPI_DIRECTION_READ) {
    bd1e:	7a63      	ldrb	r3, [r4, #9]
    bd20:	2b00      	cmp	r3, #0
    bd22:	d000      	beq.n	bd26 <_spi_interrupt_handler+0x12e>
    bd24:	e78e      	b.n	bc44 <_spi_interrupt_handler+0x4c>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_RECEIVED)) {
    bd26:	07bb      	lsls	r3, r7, #30
    bd28:	d400      	bmi.n	bd2c <_spi_interrupt_handler+0x134>
    bd2a:	e78b      	b.n	bc44 <_spi_interrupt_handler+0x4c>
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
    bd2c:	0020      	movs	r0, r4
    bd2e:	6923      	ldr	r3, [r4, #16]
    bd30:	4798      	blx	r3
    bd32:	e787      	b.n	bc44 <_spi_interrupt_handler+0x4c>
	SercomSpi *const spi_hw = &(module->hw->SPI);
    bd34:	6823      	ldr	r3, [r4, #0]
	flush = spi_hw->DATA.reg;
    bd36:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	module->remaining_dummy_buffer_length--;
    bd38:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    bd3a:	3b01      	subs	r3, #1
    bd3c:	b29b      	uxth	r3, r3
    bd3e:	8663      	strh	r3, [r4, #50]	; 0x32
				if (module->remaining_dummy_buffer_length == 0) {
    bd40:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    bd42:	b29b      	uxth	r3, r3
    bd44:	2b00      	cmp	r3, #0
    bd46:	d000      	beq.n	bd4a <_spi_interrupt_handler+0x152>
    bd48:	e77c      	b.n	bc44 <_spi_interrupt_handler+0x4c>
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    bd4a:	3304      	adds	r3, #4
    bd4c:	7533      	strb	r3, [r6, #20]
					module->status = STATUS_OK;
    bd4e:	2200      	movs	r2, #0
    bd50:	3334      	adds	r3, #52	; 0x34
    bd52:	54e2      	strb	r2, [r4, r3]
					module->dir = SPI_DIRECTION_IDLE;
    bd54:	3b35      	subs	r3, #53	; 0x35
    bd56:	7263      	strb	r3, [r4, #9]
					if (callback_mask &
    bd58:	07fb      	lsls	r3, r7, #31
    bd5a:	d400      	bmi.n	bd5e <_spi_interrupt_handler+0x166>
    bd5c:	e772      	b.n	bc44 <_spi_interrupt_handler+0x4c>
						(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])(module);
    bd5e:	0020      	movs	r0, r4
    bd60:	68e3      	ldr	r3, [r4, #12]
    bd62:	4798      	blx	r3
    bd64:	e76e      	b.n	bc44 <_spi_interrupt_handler+0x4c>
		*(module->rx_buffer_ptr) = (received_data >> 8);
    bd66:	0a1b      	lsrs	r3, r3, #8
    bd68:	7053      	strb	r3, [r2, #1]
		module->rx_buffer_ptr += 1;
    bd6a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    bd6c:	3301      	adds	r3, #1
    bd6e:	62a3      	str	r3, [r4, #40]	; 0x28
    bd70:	e7c4      	b.n	bcfc <_spi_interrupt_handler+0x104>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
    bd72:	077b      	lsls	r3, r7, #29
    bd74:	d400      	bmi.n	bd78 <_spi_interrupt_handler+0x180>
    bd76:	e765      	b.n	bc44 <_spi_interrupt_handler+0x4c>
							(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
    bd78:	0020      	movs	r0, r4
    bd7a:	6963      	ldr	r3, [r4, #20]
    bd7c:	4798      	blx	r3
    bd7e:	e761      	b.n	bc44 <_spi_interrupt_handler+0x4c>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    bd80:	7a63      	ldrb	r3, [r4, #9]
		if ((module->mode == SPI_MODE_MASTER) &&
    bd82:	2b01      	cmp	r3, #1
    bd84:	d000      	beq.n	bd88 <_spi_interrupt_handler+0x190>
    bd86:	e763      	b.n	bc50 <_spi_interrupt_handler+0x58>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    bd88:	79e3      	ldrb	r3, [r4, #7]
    bd8a:	2b00      	cmp	r3, #0
    bd8c:	d000      	beq.n	bd90 <_spi_interrupt_handler+0x198>
    bd8e:	e75f      	b.n	bc50 <_spi_interrupt_handler+0x58>
					= SPI_INTERRUPT_FLAG_TX_COMPLETE;
    bd90:	3302      	adds	r3, #2
    bd92:	7533      	strb	r3, [r6, #20]
			module->dir = SPI_DIRECTION_IDLE;
    bd94:	3301      	adds	r3, #1
    bd96:	7263      	strb	r3, [r4, #9]
			module->status = STATUS_OK;
    bd98:	2200      	movs	r2, #0
    bd9a:	3335      	adds	r3, #53	; 0x35
    bd9c:	54e2      	strb	r2, [r4, r3]
			if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
    bd9e:	07fb      	lsls	r3, r7, #31
    bda0:	d400      	bmi.n	bda4 <_spi_interrupt_handler+0x1ac>
    bda2:	e755      	b.n	bc50 <_spi_interrupt_handler+0x58>
				(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])
    bda4:	0020      	movs	r0, r4
    bda6:	68e3      	ldr	r3, [r4, #12]
    bda8:	4798      	blx	r3
    bdaa:	e751      	b.n	bc50 <_spi_interrupt_handler+0x58>
		spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
    bdac:	2380      	movs	r3, #128	; 0x80
    bdae:	7533      	strb	r3, [r6, #20]
		spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
    bdb0:	7633      	strb	r3, [r6, #24]
		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
    bdb2:	067b      	lsls	r3, r7, #25
    bdb4:	d400      	bmi.n	bdb8 <_spi_interrupt_handler+0x1c0>
    bdb6:	e74f      	b.n	bc58 <_spi_interrupt_handler+0x60>
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
    bdb8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    bdba:	0020      	movs	r0, r4
    bdbc:	4798      	blx	r3
}
    bdbe:	e74b      	b.n	bc58 <_spi_interrupt_handler+0x60>
    bdc0:	20000584 	.word	0x20000584
    bdc4:	2000059c 	.word	0x2000059c

0000bdc8 <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
    bdc8:	b5f0      	push	{r4, r5, r6, r7, lr}
    bdca:	46de      	mov	lr, fp
    bdcc:	4657      	mov	r7, sl
    bdce:	464e      	mov	r6, r9
    bdd0:	4645      	mov	r5, r8
    bdd2:	b5e0      	push	{r5, r6, r7, lr}
    bdd4:	b091      	sub	sp, #68	; 0x44
    bdd6:	0005      	movs	r5, r0
    bdd8:	000c      	movs	r4, r1
    bdda:	0016      	movs	r6, r2
	Assert(config);

	enum status_code status_code = STATUS_OK;

	/* Assign module pointer to software instance struct */
	module->hw = hw;
    bddc:	6029      	str	r1, [r5, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    bdde:	0008      	movs	r0, r1
    bde0:	4bbc      	ldr	r3, [pc, #752]	; (c0d4 <usart_init+0x30c>)
    bde2:	4798      	blx	r3
    bde4:	0002      	movs	r2, r0
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    bde6:	6823      	ldr	r3, [r4, #0]
		/* The module is busy resetting itself */
		return STATUS_BUSY;
    bde8:	2005      	movs	r0, #5
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    bdea:	07db      	lsls	r3, r3, #31
    bdec:	d506      	bpl.n	bdfc <usart_init+0x34>
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
	_sercom_instances[instance_index] = module;
#endif

	return status_code;
}
    bdee:	b011      	add	sp, #68	; 0x44
    bdf0:	bc3c      	pop	{r2, r3, r4, r5}
    bdf2:	4690      	mov	r8, r2
    bdf4:	4699      	mov	r9, r3
    bdf6:	46a2      	mov	sl, r4
    bdf8:	46ab      	mov	fp, r5
    bdfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    bdfc:	6823      	ldr	r3, [r4, #0]
		return STATUS_ERR_DENIED;
    bdfe:	3017      	adds	r0, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    be00:	079b      	lsls	r3, r3, #30
    be02:	d4f4      	bmi.n	bdee <usart_init+0x26>
    be04:	49b4      	ldr	r1, [pc, #720]	; (c0d8 <usart_init+0x310>)
    be06:	6a08      	ldr	r0, [r1, #32]
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    be08:	1c97      	adds	r7, r2, #2
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    be0a:	2301      	movs	r3, #1
    be0c:	40bb      	lsls	r3, r7
    be0e:	4303      	orrs	r3, r0
    be10:	620b      	str	r3, [r1, #32]
	gclk_chan_conf.source_generator = config->generator_source;
    be12:	a90f      	add	r1, sp, #60	; 0x3c
    be14:	272d      	movs	r7, #45	; 0x2d
    be16:	5df3      	ldrb	r3, [r6, r7]
    be18:	700b      	strb	r3, [r1, #0]
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    be1a:	3214      	adds	r2, #20
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    be1c:	b2d3      	uxtb	r3, r2
    be1e:	9302      	str	r3, [sp, #8]
    be20:	0018      	movs	r0, r3
    be22:	4bae      	ldr	r3, [pc, #696]	; (c0dc <usart_init+0x314>)
    be24:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    be26:	9802      	ldr	r0, [sp, #8]
    be28:	4bad      	ldr	r3, [pc, #692]	; (c0e0 <usart_init+0x318>)
    be2a:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    be2c:	5df0      	ldrb	r0, [r6, r7]
    be2e:	2100      	movs	r1, #0
    be30:	4bac      	ldr	r3, [pc, #688]	; (c0e4 <usart_init+0x31c>)
    be32:	4798      	blx	r3
	module->character_size = config->character_size;
    be34:	7af3      	ldrb	r3, [r6, #11]
    be36:	716b      	strb	r3, [r5, #5]
	module->receiver_enabled = config->receiver_enable;
    be38:	2324      	movs	r3, #36	; 0x24
    be3a:	5cf3      	ldrb	r3, [r6, r3]
    be3c:	71ab      	strb	r3, [r5, #6]
	module->transmitter_enabled = config->transmitter_enable;
    be3e:	2325      	movs	r3, #37	; 0x25
    be40:	5cf3      	ldrb	r3, [r6, r3]
    be42:	71eb      	strb	r3, [r5, #7]
	module->lin_slave_enabled = config->lin_slave_enable;
    be44:	7ef3      	ldrb	r3, [r6, #27]
    be46:	722b      	strb	r3, [r5, #8]
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
    be48:	7f33      	ldrb	r3, [r6, #28]
    be4a:	726b      	strb	r3, [r5, #9]
	SercomUsart *const usart_hw = &(module->hw->USART);
    be4c:	682b      	ldr	r3, [r5, #0]
    be4e:	4698      	mov	r8, r3
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    be50:	0018      	movs	r0, r3
    be52:	4ba0      	ldr	r3, [pc, #640]	; (c0d4 <usart_init+0x30c>)
    be54:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    be56:	3014      	adds	r0, #20
	uint16_t baud  = 0;
    be58:	2200      	movs	r2, #0
    be5a:	230e      	movs	r3, #14
    be5c:	a906      	add	r1, sp, #24
    be5e:	468c      	mov	ip, r1
    be60:	4463      	add	r3, ip
    be62:	801a      	strh	r2, [r3, #0]
	switch (config->sample_rate) {
    be64:	8a32      	ldrh	r2, [r6, #16]
    be66:	9202      	str	r2, [sp, #8]
    be68:	2380      	movs	r3, #128	; 0x80
    be6a:	01db      	lsls	r3, r3, #7
    be6c:	429a      	cmp	r2, r3
    be6e:	d100      	bne.n	be72 <usart_init+0xaa>
    be70:	e09e      	b.n	bfb0 <usart_init+0x1e8>
    be72:	d90f      	bls.n	be94 <usart_init+0xcc>
    be74:	23c0      	movs	r3, #192	; 0xc0
    be76:	01db      	lsls	r3, r3, #7
    be78:	9a02      	ldr	r2, [sp, #8]
    be7a:	429a      	cmp	r2, r3
    be7c:	d100      	bne.n	be80 <usart_init+0xb8>
    be7e:	e092      	b.n	bfa6 <usart_init+0x1de>
    be80:	2380      	movs	r3, #128	; 0x80
    be82:	021b      	lsls	r3, r3, #8
    be84:	429a      	cmp	r2, r3
    be86:	d000      	beq.n	be8a <usart_init+0xc2>
    be88:	e11f      	b.n	c0ca <usart_init+0x302>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
    be8a:	2303      	movs	r3, #3
    be8c:	9306      	str	r3, [sp, #24]
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    be8e:	2300      	movs	r3, #0
    be90:	9307      	str	r3, [sp, #28]
    be92:	e008      	b.n	bea6 <usart_init+0xde>
	switch (config->sample_rate) {
    be94:	2380      	movs	r3, #128	; 0x80
    be96:	019b      	lsls	r3, r3, #6
    be98:	429a      	cmp	r2, r3
    be9a:	d000      	beq.n	be9e <usart_init+0xd6>
    be9c:	e115      	b.n	c0ca <usart_init+0x302>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    be9e:	2310      	movs	r3, #16
    bea0:	9306      	str	r3, [sp, #24]
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    bea2:	3b0f      	subs	r3, #15
    bea4:	9307      	str	r3, [sp, #28]
	ctrla = (uint32_t)config->data_order |
    bea6:	6833      	ldr	r3, [r6, #0]
    bea8:	9305      	str	r3, [sp, #20]
		(uint32_t)config->mux_setting |
    beaa:	68f3      	ldr	r3, [r6, #12]
    beac:	9303      	str	r3, [sp, #12]
		config->sample_adjustment |
    beae:	6973      	ldr	r3, [r6, #20]
    beb0:	9304      	str	r3, [sp, #16]
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    beb2:	7e33      	ldrb	r3, [r6, #24]
    beb4:	469b      	mov	fp, r3
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    beb6:	2326      	movs	r3, #38	; 0x26
    beb8:	5cf3      	ldrb	r3, [r6, r3]
    beba:	469a      	mov	sl, r3
	transfer_mode = (uint32_t)config->transfer_mode;
    bebc:	6873      	ldr	r3, [r6, #4]
    bebe:	4699      	mov	r9, r3
	switch (transfer_mode)
    bec0:	2b00      	cmp	r3, #0
    bec2:	d100      	bne.n	bec6 <usart_init+0xfe>
    bec4:	e0a0      	b.n	c008 <usart_init+0x240>
    bec6:	2380      	movs	r3, #128	; 0x80
    bec8:	055b      	lsls	r3, r3, #21
    beca:	4599      	cmp	r9, r3
    becc:	d100      	bne.n	bed0 <usart_init+0x108>
    bece:	e084      	b.n	bfda <usart_init+0x212>
	if(config->encoding_format_enable) {
    bed0:	7e73      	ldrb	r3, [r6, #25]
    bed2:	2b00      	cmp	r3, #0
    bed4:	d002      	beq.n	bedc <usart_init+0x114>
		usart_hw->RXPL.reg = config->receive_pulse_length;
    bed6:	7eb3      	ldrb	r3, [r6, #26]
    bed8:	4642      	mov	r2, r8
    beda:	7393      	strb	r3, [r2, #14]
	SercomUsart *const usart_hw = &(module->hw->USART);
    bedc:	682a      	ldr	r2, [r5, #0]
    bede:	9f02      	ldr	r7, [sp, #8]
	return (usart_hw->SYNCBUSY.reg);
    bee0:	69d3      	ldr	r3, [r2, #28]
	while (usart_is_syncing(module)) {
    bee2:	2b00      	cmp	r3, #0
    bee4:	d1fc      	bne.n	bee0 <usart_init+0x118>
	usart_hw->BAUD.reg = baud;
    bee6:	330e      	adds	r3, #14
    bee8:	aa06      	add	r2, sp, #24
    beea:	4694      	mov	ip, r2
    beec:	4463      	add	r3, ip
    beee:	881b      	ldrh	r3, [r3, #0]
    bef0:	4642      	mov	r2, r8
    bef2:	8193      	strh	r3, [r2, #12]
	ctrla |= transfer_mode;
    bef4:	9b05      	ldr	r3, [sp, #20]
    bef6:	9a03      	ldr	r2, [sp, #12]
    bef8:	4313      	orrs	r3, r2
    befa:	9a04      	ldr	r2, [sp, #16]
    befc:	4313      	orrs	r3, r2
    befe:	464a      	mov	r2, r9
    bf00:	4313      	orrs	r3, r2
    bf02:	431f      	orrs	r7, r3
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    bf04:	465b      	mov	r3, fp
    bf06:	021b      	lsls	r3, r3, #8
	ctrla |= transfer_mode;
    bf08:	431f      	orrs	r7, r3
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    bf0a:	4653      	mov	r3, sl
    bf0c:	075b      	lsls	r3, r3, #29
	ctrla |= transfer_mode;
    bf0e:	431f      	orrs	r7, r3
	if (config->use_external_clock == false) {
    bf10:	2327      	movs	r3, #39	; 0x27
    bf12:	5cf3      	ldrb	r3, [r6, r3]
    bf14:	2b00      	cmp	r3, #0
    bf16:	d101      	bne.n	bf1c <usart_init+0x154>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
    bf18:	3304      	adds	r3, #4
    bf1a:	431f      	orrs	r7, r3
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
    bf1c:	7e73      	ldrb	r3, [r6, #25]
    bf1e:	029b      	lsls	r3, r3, #10
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    bf20:	7f32      	ldrb	r2, [r6, #28]
    bf22:	0252      	lsls	r2, r2, #9
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
    bf24:	4313      	orrs	r3, r2
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
    bf26:	7f72      	ldrb	r2, [r6, #29]
    bf28:	0212      	lsls	r2, r2, #8
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    bf2a:	4313      	orrs	r3, r2
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    bf2c:	2224      	movs	r2, #36	; 0x24
    bf2e:	5cb2      	ldrb	r2, [r6, r2]
    bf30:	0452      	lsls	r2, r2, #17
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
    bf32:	4313      	orrs	r3, r2
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
    bf34:	2225      	movs	r2, #37	; 0x25
    bf36:	5cb2      	ldrb	r2, [r6, r2]
    bf38:	0412      	lsls	r2, r2, #16
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    bf3a:	4313      	orrs	r3, r2
	ctrlb |= (uint32_t)config->character_size;
    bf3c:	7ab1      	ldrb	r1, [r6, #10]
    bf3e:	7af2      	ldrb	r2, [r6, #11]
    bf40:	4311      	orrs	r1, r2
    bf42:	4319      	orrs	r1, r3
	if (config->parity != USART_PARITY_NONE) {
    bf44:	8933      	ldrh	r3, [r6, #8]
    bf46:	2bff      	cmp	r3, #255	; 0xff
    bf48:	d100      	bne.n	bf4c <usart_init+0x184>
    bf4a:	e081      	b.n	c050 <usart_init+0x288>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
    bf4c:	2280      	movs	r2, #128	; 0x80
    bf4e:	0452      	lsls	r2, r2, #17
    bf50:	4317      	orrs	r7, r2
		ctrlb |= config->parity;
    bf52:	4319      	orrs	r1, r3
	if (config->run_in_standby || system_is_debugger_present()) {
    bf54:	232c      	movs	r3, #44	; 0x2c
    bf56:	5cf3      	ldrb	r3, [r6, r3]
    bf58:	2b00      	cmp	r3, #0
    bf5a:	d103      	bne.n	bf64 <usart_init+0x19c>
    bf5c:	4b62      	ldr	r3, [pc, #392]	; (c0e8 <usart_init+0x320>)
    bf5e:	789b      	ldrb	r3, [r3, #2]
    bf60:	079b      	lsls	r3, r3, #30
    bf62:	d501      	bpl.n	bf68 <usart_init+0x1a0>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
    bf64:	2380      	movs	r3, #128	; 0x80
    bf66:	431f      	orrs	r7, r3
	SercomUsart *const usart_hw = &(module->hw->USART);
    bf68:	682a      	ldr	r2, [r5, #0]
	return (usart_hw->SYNCBUSY.reg);
    bf6a:	69d3      	ldr	r3, [r2, #28]
	while (usart_is_syncing(module)) {
    bf6c:	2b00      	cmp	r3, #0
    bf6e:	d1fc      	bne.n	bf6a <usart_init+0x1a2>
	usart_hw->CTRLB.reg = ctrlb;
    bf70:	4643      	mov	r3, r8
    bf72:	6059      	str	r1, [r3, #4]
	SercomUsart *const usart_hw = &(module->hw->USART);
    bf74:	682a      	ldr	r2, [r5, #0]
	return (usart_hw->SYNCBUSY.reg);
    bf76:	69d3      	ldr	r3, [r2, #28]
	while (usart_is_syncing(module)) {
    bf78:	2b00      	cmp	r3, #0
    bf7a:	d1fc      	bne.n	bf76 <usart_init+0x1ae>
	usart_hw->CTRLA.reg = ctrla;
    bf7c:	4643      	mov	r3, r8
    bf7e:	601f      	str	r7, [r3, #0]
	config->mux_position = SYSTEM_PINMUX_GPIO;
    bf80:	ab0e      	add	r3, sp, #56	; 0x38
    bf82:	2280      	movs	r2, #128	; 0x80
    bf84:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    bf86:	2200      	movs	r2, #0
    bf88:	705a      	strb	r2, [r3, #1]
	config->powersave    = false;
    bf8a:	70da      	strb	r2, [r3, #3]
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    bf8c:	709a      	strb	r2, [r3, #2]
	uint32_t pad_pinmuxes[] = {
    bf8e:	6b33      	ldr	r3, [r6, #48]	; 0x30
    bf90:	930a      	str	r3, [sp, #40]	; 0x28
    bf92:	6b73      	ldr	r3, [r6, #52]	; 0x34
    bf94:	930b      	str	r3, [sp, #44]	; 0x2c
    bf96:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    bf98:	930c      	str	r3, [sp, #48]	; 0x30
    bf9a:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
    bf9c:	9302      	str	r3, [sp, #8]
    bf9e:	930d      	str	r3, [sp, #52]	; 0x34
    bfa0:	2700      	movs	r7, #0
		uint32_t current_pinmux = pad_pinmuxes[pad];
    bfa2:	ae0a      	add	r6, sp, #40	; 0x28
    bfa4:	e063      	b.n	c06e <usart_init+0x2a6>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    bfa6:	2308      	movs	r3, #8
    bfa8:	9306      	str	r3, [sp, #24]
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    bfaa:	3b07      	subs	r3, #7
    bfac:	9307      	str	r3, [sp, #28]
    bfae:	e77a      	b.n	bea6 <usart_init+0xde>
	ctrla = (uint32_t)config->data_order |
    bfb0:	6833      	ldr	r3, [r6, #0]
    bfb2:	9305      	str	r3, [sp, #20]
		(uint32_t)config->mux_setting |
    bfb4:	68f3      	ldr	r3, [r6, #12]
    bfb6:	9303      	str	r3, [sp, #12]
		config->sample_adjustment |
    bfb8:	6973      	ldr	r3, [r6, #20]
    bfba:	9304      	str	r3, [sp, #16]
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    bfbc:	7e33      	ldrb	r3, [r6, #24]
    bfbe:	469b      	mov	fp, r3
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    bfc0:	2326      	movs	r3, #38	; 0x26
    bfc2:	5cf3      	ldrb	r3, [r6, r3]
    bfc4:	469a      	mov	sl, r3
	transfer_mode = (uint32_t)config->transfer_mode;
    bfc6:	6873      	ldr	r3, [r6, #4]
    bfc8:	4699      	mov	r9, r3
	switch (transfer_mode)
    bfca:	2b00      	cmp	r3, #0
    bfcc:	d018      	beq.n	c000 <usart_init+0x238>
    bfce:	2380      	movs	r3, #128	; 0x80
    bfd0:	055b      	lsls	r3, r3, #21
    bfd2:	4599      	cmp	r9, r3
    bfd4:	d001      	beq.n	bfda <usart_init+0x212>
	enum status_code status_code = STATUS_OK;
    bfd6:	2000      	movs	r0, #0
    bfd8:	e025      	b.n	c026 <usart_init+0x25e>
			if (!config->use_external_clock) {
    bfda:	2327      	movs	r3, #39	; 0x27
    bfdc:	5cf3      	ldrb	r3, [r6, r3]
    bfde:	2b00      	cmp	r3, #0
    bfe0:	d000      	beq.n	bfe4 <usart_init+0x21c>
    bfe2:	e775      	b.n	bed0 <usart_init+0x108>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
    bfe4:	6a33      	ldr	r3, [r6, #32]
    bfe6:	001f      	movs	r7, r3
    bfe8:	b2c0      	uxtb	r0, r0
    bfea:	4b40      	ldr	r3, [pc, #256]	; (c0ec <usart_init+0x324>)
    bfec:	4798      	blx	r3
    bfee:	0001      	movs	r1, r0
    bff0:	220e      	movs	r2, #14
    bff2:	ab06      	add	r3, sp, #24
    bff4:	469c      	mov	ip, r3
    bff6:	4462      	add	r2, ip
    bff8:	0038      	movs	r0, r7
    bffa:	4b3d      	ldr	r3, [pc, #244]	; (c0f0 <usart_init+0x328>)
    bffc:	4798      	blx	r3
    bffe:	e012      	b.n	c026 <usart_init+0x25e>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    c000:	2308      	movs	r3, #8
    c002:	9306      	str	r3, [sp, #24]
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    c004:	2300      	movs	r3, #0
    c006:	9307      	str	r3, [sp, #28]
			if (config->use_external_clock) {
    c008:	2327      	movs	r3, #39	; 0x27
    c00a:	5cf3      	ldrb	r3, [r6, r3]
    c00c:	2b00      	cmp	r3, #0
    c00e:	d00e      	beq.n	c02e <usart_init+0x266>
				status_code =
    c010:	9b06      	ldr	r3, [sp, #24]
    c012:	9300      	str	r3, [sp, #0]
    c014:	9b07      	ldr	r3, [sp, #28]
    c016:	220e      	movs	r2, #14
    c018:	a906      	add	r1, sp, #24
    c01a:	468c      	mov	ip, r1
    c01c:	4462      	add	r2, ip
    c01e:	6ab1      	ldr	r1, [r6, #40]	; 0x28
    c020:	6a30      	ldr	r0, [r6, #32]
    c022:	4f34      	ldr	r7, [pc, #208]	; (c0f4 <usart_init+0x32c>)
    c024:	47b8      	blx	r7
	if (status_code != STATUS_OK) {
    c026:	2800      	cmp	r0, #0
    c028:	d000      	beq.n	c02c <usart_init+0x264>
    c02a:	e6e0      	b.n	bdee <usart_init+0x26>
    c02c:	e750      	b.n	bed0 <usart_init+0x108>
						_sercom_get_async_baud_val(config->baudrate,
    c02e:	6a33      	ldr	r3, [r6, #32]
    c030:	001f      	movs	r7, r3
    c032:	b2c0      	uxtb	r0, r0
    c034:	4b2d      	ldr	r3, [pc, #180]	; (c0ec <usart_init+0x324>)
    c036:	4798      	blx	r3
    c038:	0001      	movs	r1, r0
				status_code =
    c03a:	9b06      	ldr	r3, [sp, #24]
    c03c:	9300      	str	r3, [sp, #0]
    c03e:	9b07      	ldr	r3, [sp, #28]
    c040:	220e      	movs	r2, #14
    c042:	a806      	add	r0, sp, #24
    c044:	4684      	mov	ip, r0
    c046:	4462      	add	r2, ip
    c048:	0038      	movs	r0, r7
    c04a:	4f2a      	ldr	r7, [pc, #168]	; (c0f4 <usart_init+0x32c>)
    c04c:	47b8      	blx	r7
    c04e:	e7ea      	b.n	c026 <usart_init+0x25e>
		if(config->lin_slave_enable) {
    c050:	7ef3      	ldrb	r3, [r6, #27]
    c052:	2b00      	cmp	r3, #0
    c054:	d100      	bne.n	c058 <usart_init+0x290>
    c056:	e77d      	b.n	bf54 <usart_init+0x18c>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
    c058:	2380      	movs	r3, #128	; 0x80
    c05a:	04db      	lsls	r3, r3, #19
    c05c:	431f      	orrs	r7, r3
    c05e:	e779      	b.n	bf54 <usart_init+0x18c>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    c060:	0020      	movs	r0, r4
    c062:	4b25      	ldr	r3, [pc, #148]	; (c0f8 <usart_init+0x330>)
    c064:	4798      	blx	r3
    c066:	e007      	b.n	c078 <usart_init+0x2b0>
    c068:	3701      	adds	r7, #1
	for (uint8_t pad = 0; pad < 4; pad++) {
    c06a:	2f04      	cmp	r7, #4
    c06c:	d00d      	beq.n	c08a <usart_init+0x2c2>
    c06e:	b2f9      	uxtb	r1, r7
		uint32_t current_pinmux = pad_pinmuxes[pad];
    c070:	00bb      	lsls	r3, r7, #2
    c072:	5998      	ldr	r0, [r3, r6]
		if (current_pinmux == PINMUX_DEFAULT) {
    c074:	2800      	cmp	r0, #0
    c076:	d0f3      	beq.n	c060 <usart_init+0x298>
		if (current_pinmux != PINMUX_UNUSED) {
    c078:	1c43      	adds	r3, r0, #1
    c07a:	d0f5      	beq.n	c068 <usart_init+0x2a0>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    c07c:	a90e      	add	r1, sp, #56	; 0x38
    c07e:	7008      	strb	r0, [r1, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    c080:	0c00      	lsrs	r0, r0, #16
    c082:	b2c0      	uxtb	r0, r0
    c084:	4b1d      	ldr	r3, [pc, #116]	; (c0fc <usart_init+0x334>)
    c086:	4798      	blx	r3
    c088:	e7ee      	b.n	c068 <usart_init+0x2a0>
		module->callback[i]            = NULL;
    c08a:	2300      	movs	r3, #0
    c08c:	60eb      	str	r3, [r5, #12]
    c08e:	612b      	str	r3, [r5, #16]
    c090:	616b      	str	r3, [r5, #20]
    c092:	61ab      	str	r3, [r5, #24]
    c094:	61eb      	str	r3, [r5, #28]
    c096:	622b      	str	r3, [r5, #32]
	module->tx_buffer_ptr              = NULL;
    c098:	62ab      	str	r3, [r5, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
    c09a:	626b      	str	r3, [r5, #36]	; 0x24
	module->remaining_tx_buffer_length = 0x0000;
    c09c:	2200      	movs	r2, #0
    c09e:	85eb      	strh	r3, [r5, #46]	; 0x2e
	module->remaining_rx_buffer_length = 0x0000;
    c0a0:	85ab      	strh	r3, [r5, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
    c0a2:	3330      	adds	r3, #48	; 0x30
    c0a4:	54ea      	strb	r2, [r5, r3]
	module->callback_enable_mask       = 0x00;
    c0a6:	3301      	adds	r3, #1
    c0a8:	54ea      	strb	r2, [r5, r3]
	module->rx_status                  = STATUS_OK;
    c0aa:	3301      	adds	r3, #1
    c0ac:	54ea      	strb	r2, [r5, r3]
	module->tx_status                  = STATUS_OK;
    c0ae:	3301      	adds	r3, #1
    c0b0:	54ea      	strb	r2, [r5, r3]
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    c0b2:	6828      	ldr	r0, [r5, #0]
    c0b4:	4b07      	ldr	r3, [pc, #28]	; (c0d4 <usart_init+0x30c>)
    c0b6:	4798      	blx	r3
    c0b8:	0004      	movs	r4, r0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
    c0ba:	4911      	ldr	r1, [pc, #68]	; (c100 <usart_init+0x338>)
    c0bc:	4b11      	ldr	r3, [pc, #68]	; (c104 <usart_init+0x33c>)
    c0be:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    c0c0:	00a4      	lsls	r4, r4, #2
    c0c2:	4b11      	ldr	r3, [pc, #68]	; (c108 <usart_init+0x340>)
    c0c4:	50e5      	str	r5, [r4, r3]
	return status_code;
    c0c6:	2000      	movs	r0, #0
    c0c8:	e691      	b.n	bdee <usart_init+0x26>
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    c0ca:	2310      	movs	r3, #16
    c0cc:	9306      	str	r3, [sp, #24]
	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    c0ce:	2300      	movs	r3, #0
    c0d0:	9307      	str	r3, [sp, #28]
    c0d2:	e6e8      	b.n	bea6 <usart_init+0xde>
    c0d4:	0000b919 	.word	0x0000b919
    c0d8:	40000400 	.word	0x40000400
    c0dc:	0000c9dd 	.word	0x0000c9dd
    c0e0:	0000c951 	.word	0x0000c951
    c0e4:	0000b755 	.word	0x0000b755
    c0e8:	41002000 	.word	0x41002000
    c0ec:	0000c9f9 	.word	0x0000c9f9
    c0f0:	0000b697 	.word	0x0000b697
    c0f4:	0000b6c1 	.word	0x0000b6c1
    c0f8:	0000b7a1 	.word	0x0000b7a1
    c0fc:	0000cad5 	.word	0x0000cad5
    c100:	0000c20d 	.word	0x0000c20d
    c104:	0000b955 	.word	0x0000b955
    c108:	20000584 	.word	0x20000584

0000c10c <_usart_write_buffer>:
 */
enum status_code _usart_write_buffer(
		struct usart_module *const module,
		uint8_t *tx_data,
		uint16_t length)
{
    c10c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c10e:	0006      	movs	r6, r0
    c110:	000c      	movs	r4, r1
    c112:	0015      	movs	r5, r2
	Assert(module);
	Assert(module->hw);
	Assert(tx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    c114:	6807      	ldr	r7, [r0, #0]
	cpu_irq_enter_critical();
    c116:	4b0a      	ldr	r3, [pc, #40]	; (c140 <_usart_write_buffer+0x34>)
    c118:	4798      	blx	r3

	system_interrupt_enter_critical_section();

	/* Check if the USART transmitter is busy */
	if (module->remaining_tx_buffer_length > 0) {
    c11a:	8df3      	ldrh	r3, [r6, #46]	; 0x2e
    c11c:	b29b      	uxth	r3, r3
    c11e:	2b00      	cmp	r3, #0
    c120:	d003      	beq.n	c12a <_usart_write_buffer+0x1e>
	cpu_irq_leave_critical();
    c122:	4b08      	ldr	r3, [pc, #32]	; (c144 <_usart_write_buffer+0x38>)
    c124:	4798      	blx	r3
		system_interrupt_leave_critical_section();
		return STATUS_BUSY;
    c126:	2005      	movs	r0, #5

	/* Enable the Data Register Empty Interrupt */
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_DRE;

	return STATUS_OK;
}
    c128:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	module->remaining_tx_buffer_length = length;
    c12a:	85f5      	strh	r5, [r6, #46]	; 0x2e
    c12c:	4b05      	ldr	r3, [pc, #20]	; (c144 <_usart_write_buffer+0x38>)
    c12e:	4798      	blx	r3
	module->tx_buffer_ptr              = tx_data;
    c130:	62b4      	str	r4, [r6, #40]	; 0x28
	module->tx_status                  = STATUS_BUSY;
    c132:	2205      	movs	r2, #5
    c134:	2333      	movs	r3, #51	; 0x33
    c136:	54f2      	strb	r2, [r6, r3]
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_DRE;
    c138:	3b32      	subs	r3, #50	; 0x32
    c13a:	75bb      	strb	r3, [r7, #22]
	return STATUS_OK;
    c13c:	2000      	movs	r0, #0
    c13e:	e7f3      	b.n	c128 <_usart_write_buffer+0x1c>
    c140:	0000b549 	.word	0x0000b549
    c144:	0000b589 	.word	0x0000b589

0000c148 <_usart_read_buffer>:
 */
enum status_code _usart_read_buffer(
		struct usart_module *const module,
		uint8_t *rx_data,
		uint16_t length)
{
    c148:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c14a:	0004      	movs	r4, r0
    c14c:	000d      	movs	r5, r1
    c14e:	0016      	movs	r6, r2
	Assert(module);
	Assert(module->hw);
	Assert(rx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    c150:	6807      	ldr	r7, [r0, #0]
	cpu_irq_enter_critical();
    c152:	4b0f      	ldr	r3, [pc, #60]	; (c190 <_usart_read_buffer+0x48>)
    c154:	4798      	blx	r3

	system_interrupt_enter_critical_section();

	/* Check if the USART receiver is busy */
	if (module->remaining_rx_buffer_length > 0) {
    c156:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    c158:	b29b      	uxth	r3, r3
    c15a:	2b00      	cmp	r3, #0
    c15c:	d003      	beq.n	c166 <_usart_read_buffer+0x1e>
	cpu_irq_leave_critical();
    c15e:	4b0d      	ldr	r3, [pc, #52]	; (c194 <_usart_read_buffer+0x4c>)
    c160:	4798      	blx	r3
		system_interrupt_leave_critical_section();
		return STATUS_BUSY;
    c162:	2005      	movs	r0, #5
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXS;
	}
#endif

	return STATUS_OK;
}
    c164:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	module->remaining_rx_buffer_length = length;
    c166:	85a6      	strh	r6, [r4, #44]	; 0x2c
    c168:	4b0a      	ldr	r3, [pc, #40]	; (c194 <_usart_read_buffer+0x4c>)
    c16a:	4798      	blx	r3
	module->rx_buffer_ptr              = rx_data;
    c16c:	6265      	str	r5, [r4, #36]	; 0x24
	module->rx_status                  = STATUS_BUSY;
    c16e:	2205      	movs	r2, #5
    c170:	2332      	movs	r3, #50	; 0x32
    c172:	54e2      	strb	r2, [r4, r3]
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXC;
    c174:	3b2e      	subs	r3, #46	; 0x2e
    c176:	75bb      	strb	r3, [r7, #22]
	if(module->lin_slave_enabled) {
    c178:	7a23      	ldrb	r3, [r4, #8]
    c17a:	2b00      	cmp	r3, #0
    c17c:	d001      	beq.n	c182 <_usart_read_buffer+0x3a>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXBRK;
    c17e:	2320      	movs	r3, #32
    c180:	75bb      	strb	r3, [r7, #22]
	if(module->start_frame_detection_enabled) {
    c182:	7a63      	ldrb	r3, [r4, #9]
	return STATUS_OK;
    c184:	2000      	movs	r0, #0
	if(module->start_frame_detection_enabled) {
    c186:	2b00      	cmp	r3, #0
    c188:	d0ec      	beq.n	c164 <_usart_read_buffer+0x1c>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXS;
    c18a:	2308      	movs	r3, #8
    c18c:	75bb      	strb	r3, [r7, #22]
    c18e:	e7e9      	b.n	c164 <_usart_read_buffer+0x1c>
    c190:	0000b549 	.word	0x0000b549
    c194:	0000b589 	.word	0x0000b589

0000c198 <usart_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    c198:	1c93      	adds	r3, r2, #2
    c19a:	009b      	lsls	r3, r3, #2
    c19c:	18c3      	adds	r3, r0, r3
    c19e:	6059      	str	r1, [r3, #4]

	/* Set the bit corresponding to the callback_type */
	module->callback_reg_mask |= (1 << callback_type);
    c1a0:	2130      	movs	r1, #48	; 0x30
    c1a2:	2301      	movs	r3, #1
    c1a4:	4093      	lsls	r3, r2
    c1a6:	001a      	movs	r2, r3
    c1a8:	5c43      	ldrb	r3, [r0, r1]
    c1aa:	4313      	orrs	r3, r2
    c1ac:	5443      	strb	r3, [r0, r1]
}
    c1ae:	4770      	bx	lr

0000c1b0 <usart_write_buffer_job>:
 */
enum status_code usart_write_buffer_job(
		struct usart_module *const module,
		uint8_t *tx_data,
		uint16_t length)
{
    c1b0:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(tx_data);

	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
    c1b2:	2317      	movs	r3, #23
	if (length == 0) {
    c1b4:	2a00      	cmp	r2, #0
    c1b6:	d101      	bne.n	c1bc <usart_write_buffer_job+0xc>
		return STATUS_ERR_DENIED;
	}

	/* Issue internal asynchronous write */
	return _usart_write_buffer(module, tx_data, length);
}
    c1b8:	0018      	movs	r0, r3
    c1ba:	bd10      	pop	{r4, pc}
	if (!(module->transmitter_enabled)) {
    c1bc:	79c4      	ldrb	r4, [r0, #7]
		return STATUS_ERR_DENIED;
    c1be:	3305      	adds	r3, #5
	if (!(module->transmitter_enabled)) {
    c1c0:	2c00      	cmp	r4, #0
    c1c2:	d0f9      	beq.n	c1b8 <usart_write_buffer_job+0x8>
	return _usart_write_buffer(module, tx_data, length);
    c1c4:	4b01      	ldr	r3, [pc, #4]	; (c1cc <usart_write_buffer_job+0x1c>)
    c1c6:	4798      	blx	r3
    c1c8:	0003      	movs	r3, r0
    c1ca:	e7f5      	b.n	c1b8 <usart_write_buffer_job+0x8>
    c1cc:	0000c10d 	.word	0x0000c10d

0000c1d0 <usart_read_buffer_job>:
 */
enum status_code usart_read_buffer_job(
		struct usart_module *const module,
		uint8_t *rx_data,
		uint16_t length)
{
    c1d0:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(rx_data);

	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
    c1d2:	2317      	movs	r3, #23
	if (length == 0) {
    c1d4:	2a00      	cmp	r2, #0
    c1d6:	d101      	bne.n	c1dc <usart_read_buffer_job+0xc>
		return STATUS_ERR_DENIED;
	}

	/* Issue internal asynchronous read */
	return _usart_read_buffer(module, rx_data, length);
}
    c1d8:	0018      	movs	r0, r3
    c1da:	bd10      	pop	{r4, pc}
	if (!(module->receiver_enabled)) {
    c1dc:	7984      	ldrb	r4, [r0, #6]
		return STATUS_ERR_DENIED;
    c1de:	3305      	adds	r3, #5
	if (!(module->receiver_enabled)) {
    c1e0:	2c00      	cmp	r4, #0
    c1e2:	d0f9      	beq.n	c1d8 <usart_read_buffer_job+0x8>
	return _usart_read_buffer(module, rx_data, length);
    c1e4:	4b01      	ldr	r3, [pc, #4]	; (c1ec <usart_read_buffer_job+0x1c>)
    c1e6:	4798      	blx	r3
    c1e8:	0003      	movs	r3, r0
    c1ea:	e7f5      	b.n	c1d8 <usart_read_buffer_job+0x8>
    c1ec:	0000c149 	.word	0x0000c149

0000c1f0 <usart_get_job_status>:
	Assert(module);

	/* Variable for status code */
	enum status_code status_code;

	switch(transceiver_type) {
    c1f0:	2900      	cmp	r1, #0
    c1f2:	d003      	beq.n	c1fc <usart_get_job_status+0xc>
    c1f4:	2901      	cmp	r1, #1
    c1f6:	d005      	beq.n	c204 <usart_get_job_status+0x14>
	case USART_TRANSCEIVER_TX:
			status_code = module->tx_status;
			break;

	default:
			status_code = STATUS_ERR_INVALID_ARG;
    c1f8:	2017      	movs	r0, #23
    c1fa:	e002      	b.n	c202 <usart_get_job_status+0x12>
			status_code = module->rx_status;
    c1fc:	2332      	movs	r3, #50	; 0x32
    c1fe:	5cc0      	ldrb	r0, [r0, r3]
    c200:	b2c0      	uxtb	r0, r0
			break;
	}

	return status_code;
}
    c202:	4770      	bx	lr
			status_code = module->tx_status;
    c204:	2333      	movs	r3, #51	; 0x33
    c206:	5cc0      	ldrb	r0, [r0, r3]
    c208:	b2c0      	uxtb	r0, r0
			break;
    c20a:	e7fa      	b.n	c202 <usart_get_job_status+0x12>

0000c20c <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
    c20c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
    c20e:	0080      	lsls	r0, r0, #2
    c210:	4b62      	ldr	r3, [pc, #392]	; (c39c <_usart_interrupt_handler+0x190>)
    c212:	58c5      	ldr	r5, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
    c214:	682c      	ldr	r4, [r5, #0]
	return (usart_hw->SYNCBUSY.reg);
    c216:	69e3      	ldr	r3, [r4, #28]
	while (usart_is_syncing(module)) {
    c218:	2b00      	cmp	r3, #0
    c21a:	d1fc      	bne.n	c216 <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
    c21c:	7e23      	ldrb	r3, [r4, #24]
	interrupt_status &= usart_hw->INTENSET.reg;
    c21e:	7da6      	ldrb	r6, [r4, #22]
    c220:	401e      	ands	r6, r3
	callback_status = module->callback_reg_mask &
    c222:	2330      	movs	r3, #48	; 0x30
    c224:	5ceb      	ldrb	r3, [r5, r3]
    c226:	2231      	movs	r2, #49	; 0x31
    c228:	5caf      	ldrb	r7, [r5, r2]
    c22a:	401f      	ands	r7, r3
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
    c22c:	07f3      	lsls	r3, r6, #31
    c22e:	d522      	bpl.n	c276 <_usart_interrupt_handler+0x6a>
		if (module->remaining_tx_buffer_length) {
    c230:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    c232:	b29b      	uxth	r3, r3
    c234:	2b00      	cmp	r3, #0
    c236:	d01c      	beq.n	c272 <_usart_interrupt_handler+0x66>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    c238:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    c23a:	7813      	ldrb	r3, [r2, #0]
    c23c:	b2db      	uxtb	r3, r3
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
    c23e:	1c51      	adds	r1, r2, #1
    c240:	62a9      	str	r1, [r5, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    c242:	7969      	ldrb	r1, [r5, #5]
    c244:	2901      	cmp	r1, #1
    c246:	d00e      	beq.n	c266 <_usart_interrupt_handler+0x5a>
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    c248:	b29b      	uxth	r3, r3
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
    c24a:	05db      	lsls	r3, r3, #23
    c24c:	0ddb      	lsrs	r3, r3, #23
    c24e:	8523      	strh	r3, [r4, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
    c250:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    c252:	3b01      	subs	r3, #1
    c254:	b29b      	uxth	r3, r3
    c256:	85eb      	strh	r3, [r5, #46]	; 0x2e
    c258:	2b00      	cmp	r3, #0
    c25a:	d10c      	bne.n	c276 <_usart_interrupt_handler+0x6a>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    c25c:	3301      	adds	r3, #1
    c25e:	7523      	strb	r3, [r4, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
    c260:	3301      	adds	r3, #1
    c262:	75a3      	strb	r3, [r4, #22]
    c264:	e007      	b.n	c276 <_usart_interrupt_handler+0x6a>
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
    c266:	7851      	ldrb	r1, [r2, #1]
    c268:	0209      	lsls	r1, r1, #8
    c26a:	430b      	orrs	r3, r1
				(module->tx_buffer_ptr)++;
    c26c:	3202      	adds	r2, #2
    c26e:	62aa      	str	r2, [r5, #40]	; 0x28
    c270:	e7eb      	b.n	c24a <_usart_interrupt_handler+0x3e>

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    c272:	2301      	movs	r3, #1
    c274:	7523      	strb	r3, [r4, #20]
		}
	}

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
    c276:	07b3      	lsls	r3, r6, #30
    c278:	d506      	bpl.n	c288 <_usart_interrupt_handler+0x7c>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
    c27a:	2302      	movs	r3, #2
    c27c:	7523      	strb	r3, [r4, #20]
		module->tx_status = STATUS_OK;
    c27e:	2200      	movs	r2, #0
    c280:	3331      	adds	r3, #49	; 0x31
    c282:	54ea      	strb	r2, [r5, r3]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
    c284:	07fb      	lsls	r3, r7, #31
    c286:	d41a      	bmi.n	c2be <_usart_interrupt_handler+0xb2>
		}
	}

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
    c288:	0773      	lsls	r3, r6, #29
    c28a:	d565      	bpl.n	c358 <_usart_interrupt_handler+0x14c>

		if (module->remaining_rx_buffer_length) {
    c28c:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    c28e:	b29b      	uxth	r3, r3
    c290:	2b00      	cmp	r3, #0
    c292:	d05f      	beq.n	c354 <_usart_interrupt_handler+0x148>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    c294:	8b63      	ldrh	r3, [r4, #26]
    c296:	b2db      	uxtb	r3, r3
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
    c298:	071a      	lsls	r2, r3, #28
    c29a:	d414      	bmi.n	c2c6 <_usart_interrupt_handler+0xba>
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    c29c:	223f      	movs	r2, #63	; 0x3f
    c29e:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
    c2a0:	2b00      	cmp	r3, #0
    c2a2:	d034      	beq.n	c30e <_usart_interrupt_handler+0x102>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
    c2a4:	079a      	lsls	r2, r3, #30
    c2a6:	d511      	bpl.n	c2cc <_usart_interrupt_handler+0xc0>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
    c2a8:	221a      	movs	r2, #26
    c2aa:	2332      	movs	r3, #50	; 0x32
    c2ac:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
    c2ae:	3b30      	subs	r3, #48	; 0x30
    c2b0:	8363      	strh	r3, [r4, #26]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_COLL;
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
    c2b2:	077b      	lsls	r3, r7, #29
    c2b4:	d550      	bpl.n	c358 <_usart_interrupt_handler+0x14c>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
    c2b6:	0028      	movs	r0, r5
    c2b8:	696b      	ldr	r3, [r5, #20]
    c2ba:	4798      	blx	r3
    c2bc:	e04c      	b.n	c358 <_usart_interrupt_handler+0x14c>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
    c2be:	0028      	movs	r0, r5
    c2c0:	68eb      	ldr	r3, [r5, #12]
    c2c2:	4798      	blx	r3
    c2c4:	e7e0      	b.n	c288 <_usart_interrupt_handler+0x7c>
				error_code &= ~SERCOM_USART_STATUS_CTS;
    c2c6:	2237      	movs	r2, #55	; 0x37
    c2c8:	4013      	ands	r3, r2
    c2ca:	e7e9      	b.n	c2a0 <_usart_interrupt_handler+0x94>
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    c2cc:	075a      	lsls	r2, r3, #29
    c2ce:	d505      	bpl.n	c2dc <_usart_interrupt_handler+0xd0>
					module->rx_status = STATUS_ERR_OVERFLOW;
    c2d0:	221e      	movs	r2, #30
    c2d2:	2332      	movs	r3, #50	; 0x32
    c2d4:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
    c2d6:	3b2e      	subs	r3, #46	; 0x2e
    c2d8:	8363      	strh	r3, [r4, #26]
    c2da:	e7ea      	b.n	c2b2 <_usart_interrupt_handler+0xa6>
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
    c2dc:	07da      	lsls	r2, r3, #31
    c2de:	d505      	bpl.n	c2ec <_usart_interrupt_handler+0xe0>
					module->rx_status = STATUS_ERR_BAD_DATA;
    c2e0:	2213      	movs	r2, #19
    c2e2:	2332      	movs	r3, #50	; 0x32
    c2e4:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
    c2e6:	3b31      	subs	r3, #49	; 0x31
    c2e8:	8363      	strh	r3, [r4, #26]
    c2ea:	e7e2      	b.n	c2b2 <_usart_interrupt_handler+0xa6>
				else if (error_code & SERCOM_USART_STATUS_ISF) {
    c2ec:	06da      	lsls	r2, r3, #27
    c2ee:	d505      	bpl.n	c2fc <_usart_interrupt_handler+0xf0>
					module->rx_status = STATUS_ERR_PROTOCOL;
    c2f0:	2242      	movs	r2, #66	; 0x42
    c2f2:	2332      	movs	r3, #50	; 0x32
    c2f4:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_ISF;
    c2f6:	3b22      	subs	r3, #34	; 0x22
    c2f8:	8363      	strh	r3, [r4, #26]
    c2fa:	e7da      	b.n	c2b2 <_usart_interrupt_handler+0xa6>
				else if (error_code & SERCOM_USART_STATUS_COLL) {
    c2fc:	2220      	movs	r2, #32
    c2fe:	421a      	tst	r2, r3
    c300:	d0d7      	beq.n	c2b2 <_usart_interrupt_handler+0xa6>
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
    c302:	3221      	adds	r2, #33	; 0x21
    c304:	2332      	movs	r3, #50	; 0x32
    c306:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_COLL;
    c308:	3b12      	subs	r3, #18
    c30a:	8363      	strh	r3, [r4, #26]
    c30c:	e7d1      	b.n	c2b2 <_usart_interrupt_handler+0xa6>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    c30e:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    c310:	05db      	lsls	r3, r3, #23
    c312:	0ddb      	lsrs	r3, r3, #23

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
    c314:	b2da      	uxtb	r2, r3
    c316:	6a69      	ldr	r1, [r5, #36]	; 0x24
    c318:	700a      	strb	r2, [r1, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
    c31a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    c31c:	1c51      	adds	r1, r2, #1
    c31e:	6269      	str	r1, [r5, #36]	; 0x24

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    c320:	7969      	ldrb	r1, [r5, #5]
    c322:	2901      	cmp	r1, #1
    c324:	d010      	beq.n	c348 <_usart_interrupt_handler+0x13c>
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
    c326:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    c328:	3b01      	subs	r3, #1
    c32a:	b29b      	uxth	r3, r3
    c32c:	85ab      	strh	r3, [r5, #44]	; 0x2c
    c32e:	2b00      	cmp	r3, #0
    c330:	d112      	bne.n	c358 <_usart_interrupt_handler+0x14c>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    c332:	3304      	adds	r3, #4
    c334:	7523      	strb	r3, [r4, #20]
					module->rx_status = STATUS_OK;
    c336:	2200      	movs	r2, #0
    c338:	332e      	adds	r3, #46	; 0x2e
    c33a:	54ea      	strb	r2, [r5, r3]

					/* Run callback if registered and enabled */
					if (callback_status
    c33c:	07bb      	lsls	r3, r7, #30
    c33e:	d50b      	bpl.n	c358 <_usart_interrupt_handler+0x14c>
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
    c340:	0028      	movs	r0, r5
    c342:	692b      	ldr	r3, [r5, #16]
    c344:	4798      	blx	r3
    c346:	e007      	b.n	c358 <_usart_interrupt_handler+0x14c>
					*(module->rx_buffer_ptr) = (received_data >> 8);
    c348:	0a1b      	lsrs	r3, r3, #8
    c34a:	7053      	strb	r3, [r2, #1]
					module->rx_buffer_ptr += 1;
    c34c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    c34e:	3301      	adds	r3, #1
    c350:	626b      	str	r3, [r5, #36]	; 0x24
    c352:	e7e8      	b.n	c326 <_usart_interrupt_handler+0x11a>
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    c354:	2304      	movs	r3, #4
    c356:	7523      	strb	r3, [r4, #20]
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
    c358:	06f3      	lsls	r3, r6, #27
    c35a:	d504      	bpl.n	c366 <_usart_interrupt_handler+0x15a>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
    c35c:	2310      	movs	r3, #16
    c35e:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
    c360:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
    c362:	06fb      	lsls	r3, r7, #27
    c364:	d40e      	bmi.n	c384 <_usart_interrupt_handler+0x178>
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
    c366:	06b3      	lsls	r3, r6, #26
    c368:	d504      	bpl.n	c374 <_usart_interrupt_handler+0x168>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
    c36a:	2320      	movs	r3, #32
    c36c:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
    c36e:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
    c370:	073b      	lsls	r3, r7, #28
    c372:	d40b      	bmi.n	c38c <_usart_interrupt_handler+0x180>
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
    c374:	0733      	lsls	r3, r6, #28
    c376:	d504      	bpl.n	c382 <_usart_interrupt_handler+0x176>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
    c378:	2308      	movs	r3, #8
    c37a:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
    c37c:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
    c37e:	06bb      	lsls	r3, r7, #26
    c380:	d408      	bmi.n	c394 <_usart_interrupt_handler+0x188>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
		}
	}
#endif
}
    c382:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
    c384:	0028      	movs	r0, r5
    c386:	69eb      	ldr	r3, [r5, #28]
    c388:	4798      	blx	r3
    c38a:	e7ec      	b.n	c366 <_usart_interrupt_handler+0x15a>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
    c38c:	0028      	movs	r0, r5
    c38e:	69ab      	ldr	r3, [r5, #24]
    c390:	4798      	blx	r3
    c392:	e7ef      	b.n	c374 <_usart_interrupt_handler+0x168>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
    c394:	6a2b      	ldr	r3, [r5, #32]
    c396:	0028      	movs	r0, r5
    c398:	4798      	blx	r3
}
    c39a:	e7f2      	b.n	c382 <_usart_interrupt_handler+0x176>
    c39c:	20000584 	.word	0x20000584

0000c3a0 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    c3a0:	b510      	push	{r4, lr}
	switch (clock_source) {
    c3a2:	2808      	cmp	r0, #8
    c3a4:	d803      	bhi.n	c3ae <system_clock_source_get_hz+0xe>
    c3a6:	0080      	lsls	r0, r0, #2
    c3a8:	4b1c      	ldr	r3, [pc, #112]	; (c41c <system_clock_source_get_hz+0x7c>)
    c3aa:	581b      	ldr	r3, [r3, r0]
    c3ac:	469f      	mov	pc, r3

		return _system_clock_inst.dpll.frequency;
#endif

	default:
		return 0;
    c3ae:	2000      	movs	r0, #0
    c3b0:	e032      	b.n	c418 <system_clock_source_get_hz+0x78>
		return _system_clock_inst.xosc.frequency;
    c3b2:	4b1b      	ldr	r3, [pc, #108]	; (c420 <system_clock_source_get_hz+0x80>)
    c3b4:	6918      	ldr	r0, [r3, #16]
    c3b6:	e02f      	b.n	c418 <system_clock_source_get_hz+0x78>
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    c3b8:	4b1a      	ldr	r3, [pc, #104]	; (c424 <system_clock_source_get_hz+0x84>)
    c3ba:	6a1b      	ldr	r3, [r3, #32]
    c3bc:	059b      	lsls	r3, r3, #22
    c3be:	0f9b      	lsrs	r3, r3, #30
    c3c0:	4819      	ldr	r0, [pc, #100]	; (c428 <system_clock_source_get_hz+0x88>)
    c3c2:	40d8      	lsrs	r0, r3
    c3c4:	e028      	b.n	c418 <system_clock_source_get_hz+0x78>
		return _system_clock_inst.xosc32k.frequency;
    c3c6:	4b16      	ldr	r3, [pc, #88]	; (c420 <system_clock_source_get_hz+0x80>)
    c3c8:	6958      	ldr	r0, [r3, #20]
    c3ca:	e025      	b.n	c418 <system_clock_source_get_hz+0x78>
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    c3cc:	4b14      	ldr	r3, [pc, #80]	; (c420 <system_clock_source_get_hz+0x80>)
    c3ce:	681b      	ldr	r3, [r3, #0]
			return 0;
    c3d0:	2000      	movs	r0, #0
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    c3d2:	079b      	lsls	r3, r3, #30
    c3d4:	d520      	bpl.n	c418 <system_clock_source_get_hz+0x78>
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    c3d6:	4913      	ldr	r1, [pc, #76]	; (c424 <system_clock_source_get_hz+0x84>)
    c3d8:	2210      	movs	r2, #16
    c3da:	68cb      	ldr	r3, [r1, #12]
    c3dc:	421a      	tst	r2, r3
    c3de:	d0fc      	beq.n	c3da <system_clock_source_get_hz+0x3a>
		switch(_system_clock_inst.dfll.control &
    c3e0:	4b0f      	ldr	r3, [pc, #60]	; (c420 <system_clock_source_get_hz+0x80>)
    c3e2:	681a      	ldr	r2, [r3, #0]
    c3e4:	2324      	movs	r3, #36	; 0x24
    c3e6:	4013      	ands	r3, r2
    c3e8:	2b04      	cmp	r3, #4
    c3ea:	d001      	beq.n	c3f0 <system_clock_source_get_hz+0x50>
			return 48000000UL;
    c3ec:	480f      	ldr	r0, [pc, #60]	; (c42c <system_clock_source_get_hz+0x8c>)
    c3ee:	e013      	b.n	c418 <system_clock_source_get_hz+0x78>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    c3f0:	2000      	movs	r0, #0
    c3f2:	4b0f      	ldr	r3, [pc, #60]	; (c430 <system_clock_source_get_hz+0x90>)
    c3f4:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    c3f6:	4b0a      	ldr	r3, [pc, #40]	; (c420 <system_clock_source_get_hz+0x80>)
    c3f8:	689b      	ldr	r3, [r3, #8]
    c3fa:	041b      	lsls	r3, r3, #16
    c3fc:	0c1b      	lsrs	r3, r3, #16
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    c3fe:	4358      	muls	r0, r3
    c400:	e00a      	b.n	c418 <system_clock_source_get_hz+0x78>
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    c402:	2350      	movs	r3, #80	; 0x50
    c404:	4a07      	ldr	r2, [pc, #28]	; (c424 <system_clock_source_get_hz+0x84>)
    c406:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
    c408:	2000      	movs	r0, #0
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    c40a:	075b      	lsls	r3, r3, #29
    c40c:	d504      	bpl.n	c418 <system_clock_source_get_hz+0x78>
		return _system_clock_inst.dpll.frequency;
    c40e:	4b04      	ldr	r3, [pc, #16]	; (c420 <system_clock_source_get_hz+0x80>)
    c410:	68d8      	ldr	r0, [r3, #12]
    c412:	e001      	b.n	c418 <system_clock_source_get_hz+0x78>
		return 32768UL;
    c414:	2080      	movs	r0, #128	; 0x80
    c416:	0200      	lsls	r0, r0, #8
	}
}
    c418:	bd10      	pop	{r4, pc}
    c41a:	46c0      	nop			; (mov r8, r8)
    c41c:	0000d230 	.word	0x0000d230
    c420:	2000011c 	.word	0x2000011c
    c424:	40000800 	.word	0x40000800
    c428:	007a1200 	.word	0x007a1200
    c42c:	02dc6c00 	.word	0x02dc6c00
    c430:	0000c9f9 	.word	0x0000c9f9

0000c434 <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    c434:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    c436:	490c      	ldr	r1, [pc, #48]	; (c468 <system_clock_source_osc8m_set_config+0x34>)
    c438:	6a0b      	ldr	r3, [r1, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    c43a:	7804      	ldrb	r4, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
    c43c:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    c43e:	7840      	ldrb	r0, [r0, #1]
    c440:	2201      	movs	r2, #1
    c442:	4010      	ands	r0, r2
    c444:	0180      	lsls	r0, r0, #6
    c446:	2640      	movs	r6, #64	; 0x40
    c448:	43b3      	bics	r3, r6
    c44a:	4303      	orrs	r3, r0
    c44c:	402a      	ands	r2, r5
    c44e:	01d2      	lsls	r2, r2, #7
    c450:	2080      	movs	r0, #128	; 0x80
    c452:	4383      	bics	r3, r0
    c454:	4313      	orrs	r3, r2
    c456:	2203      	movs	r2, #3
    c458:	4022      	ands	r2, r4
    c45a:	0212      	lsls	r2, r2, #8
    c45c:	4803      	ldr	r0, [pc, #12]	; (c46c <system_clock_source_osc8m_set_config+0x38>)
    c45e:	4003      	ands	r3, r0
    c460:	4313      	orrs	r3, r2
    c462:	620b      	str	r3, [r1, #32]
}
    c464:	bd70      	pop	{r4, r5, r6, pc}
    c466:	46c0      	nop			; (mov r8, r8)
    c468:	40000800 	.word	0x40000800
    c46c:	fffffcff 	.word	0xfffffcff

0000c470 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    c470:	b5f0      	push	{r4, r5, r6, r7, lr}
    c472:	46de      	mov	lr, fp
    c474:	4657      	mov	r7, sl
    c476:	464e      	mov	r6, r9
    c478:	4645      	mov	r5, r8
    c47a:	b5e0      	push	{r5, r6, r7, lr}
    c47c:	0001      	movs	r1, r0
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    c47e:	4b26      	ldr	r3, [pc, #152]	; (c518 <system_clock_source_xosc32k_set_config+0xa8>)
    c480:	469b      	mov	fp, r3
    c482:	8a9b      	ldrh	r3, [r3, #20]

	temp.bit.STARTUP = config->startup_time;
    c484:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    c486:	7800      	ldrb	r0, [r0, #0]
    c488:	4242      	negs	r2, r0
    c48a:	4142      	adcs	r2, r0
    c48c:	4691      	mov	r9, r2
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
    c48e:	7888      	ldrb	r0, [r1, #2]
	temp.bit.EN1K = config->enable_1khz_output;
    c490:	78ca      	ldrb	r2, [r1, #3]
    c492:	4694      	mov	ip, r2
	temp.bit.EN32K = config->enable_32khz_output;
    c494:	790a      	ldrb	r2, [r1, #4]
    c496:	4690      	mov	r8, r2

	temp.bit.ONDEMAND = config->on_demand;
    c498:	7b4e      	ldrb	r6, [r1, #13]
	temp.bit.RUNSTDBY = config->run_in_standby;
    c49a:	7b0f      	ldrb	r7, [r1, #12]
	temp.bit.WRTLOCK  = config->write_once;
    c49c:	7b8c      	ldrb	r4, [r1, #14]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    c49e:	688a      	ldr	r2, [r1, #8]
    c4a0:	491e      	ldr	r1, [pc, #120]	; (c51c <system_clock_source_xosc32k_set_config+0xac>)
    c4a2:	614a      	str	r2, [r1, #20]

	SYSCTRL->XOSC32K = temp;
    c4a4:	2101      	movs	r1, #1
    c4a6:	464a      	mov	r2, r9
    c4a8:	0092      	lsls	r2, r2, #2
    c4aa:	4691      	mov	r9, r2
    c4ac:	2204      	movs	r2, #4
    c4ae:	4393      	bics	r3, r2
    c4b0:	464a      	mov	r2, r9
    c4b2:	4313      	orrs	r3, r2
    c4b4:	4642      	mov	r2, r8
    c4b6:	400a      	ands	r2, r1
    c4b8:	00d2      	lsls	r2, r2, #3
    c4ba:	4690      	mov	r8, r2
    c4bc:	2208      	movs	r2, #8
    c4be:	4393      	bics	r3, r2
    c4c0:	4642      	mov	r2, r8
    c4c2:	4313      	orrs	r3, r2
    c4c4:	4662      	mov	r2, ip
    c4c6:	400a      	ands	r2, r1
    c4c8:	0112      	lsls	r2, r2, #4
    c4ca:	4694      	mov	ip, r2
    c4cc:	2210      	movs	r2, #16
    c4ce:	4393      	bics	r3, r2
    c4d0:	4662      	mov	r2, ip
    c4d2:	4313      	orrs	r3, r2
    c4d4:	4008      	ands	r0, r1
    c4d6:	0140      	lsls	r0, r0, #5
    c4d8:	2220      	movs	r2, #32
    c4da:	4393      	bics	r3, r2
    c4dc:	4303      	orrs	r3, r0
    c4de:	400f      	ands	r7, r1
    c4e0:	01bf      	lsls	r7, r7, #6
    c4e2:	2040      	movs	r0, #64	; 0x40
    c4e4:	4383      	bics	r3, r0
    c4e6:	433b      	orrs	r3, r7
    c4e8:	400e      	ands	r6, r1
    c4ea:	01f6      	lsls	r6, r6, #7
    c4ec:	3040      	adds	r0, #64	; 0x40
    c4ee:	4383      	bics	r3, r0
    c4f0:	4333      	orrs	r3, r6
    c4f2:	3879      	subs	r0, #121	; 0x79
    c4f4:	4005      	ands	r5, r0
    c4f6:	022d      	lsls	r5, r5, #8
    c4f8:	4809      	ldr	r0, [pc, #36]	; (c520 <system_clock_source_xosc32k_set_config+0xb0>)
    c4fa:	4003      	ands	r3, r0
    c4fc:	432b      	orrs	r3, r5
    c4fe:	4021      	ands	r1, r4
    c500:	0309      	lsls	r1, r1, #12
    c502:	4808      	ldr	r0, [pc, #32]	; (c524 <system_clock_source_xosc32k_set_config+0xb4>)
    c504:	4003      	ands	r3, r0
    c506:	430b      	orrs	r3, r1
    c508:	465a      	mov	r2, fp
    c50a:	8293      	strh	r3, [r2, #20]
}
    c50c:	bc3c      	pop	{r2, r3, r4, r5}
    c50e:	4690      	mov	r8, r2
    c510:	4699      	mov	r9, r3
    c512:	46a2      	mov	sl, r4
    c514:	46ab      	mov	fp, r5
    c516:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c518:	40000800 	.word	0x40000800
    c51c:	2000011c 	.word	0x2000011c
    c520:	fffff8ff 	.word	0xfffff8ff
    c524:	ffffefff 	.word	0xffffefff

0000c528 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    c528:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    c52a:	7a03      	ldrb	r3, [r0, #8]
    c52c:	069b      	lsls	r3, r3, #26
    c52e:	0c1b      	lsrs	r3, r3, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
    c530:	8942      	ldrh	r2, [r0, #10]
    c532:	0592      	lsls	r2, r2, #22
    c534:	0d92      	lsrs	r2, r2, #22
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    c536:	4313      	orrs	r3, r2
	_system_clock_inst.dfll.val =
    c538:	4918      	ldr	r1, [pc, #96]	; (c59c <system_clock_source_dfll_set_config+0x74>)
    c53a:	604b      	str	r3, [r1, #4]

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
    c53c:	7983      	ldrb	r3, [r0, #6]
    c53e:	79c2      	ldrb	r2, [r0, #7]
    c540:	4313      	orrs	r3, r2
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
    c542:	8842      	ldrh	r2, [r0, #2]
    c544:	8884      	ldrh	r4, [r0, #4]
    c546:	4322      	orrs	r2, r4
    c548:	4313      	orrs	r3, r2
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
    c54a:	7842      	ldrb	r2, [r0, #1]
    c54c:	01d2      	lsls	r2, r2, #7
			(uint32_t)config->chill_cycle     |
    c54e:	4313      	orrs	r3, r2
	_system_clock_inst.dfll.control =
    c550:	600b      	str	r3, [r1, #0]

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    c552:	7803      	ldrb	r3, [r0, #0]
    c554:	2b04      	cmp	r3, #4
    c556:	d011      	beq.n	c57c <system_clock_source_dfll_set_config+0x54>
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
    c558:	2b20      	cmp	r3, #32
    c55a:	d10e      	bne.n	c57a <system_clock_source_dfll_set_config+0x52>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    c55c:	7b03      	ldrb	r3, [r0, #12]
    c55e:	069b      	lsls	r3, r3, #26
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    c560:	8a02      	ldrh	r2, [r0, #16]
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    c562:	4313      	orrs	r3, r2
    c564:	89c2      	ldrh	r2, [r0, #14]
    c566:	0412      	lsls	r2, r2, #16
    c568:	490d      	ldr	r1, [pc, #52]	; (c5a0 <system_clock_source_dfll_set_config+0x78>)
    c56a:	400a      	ands	r2, r1
    c56c:	4313      	orrs	r3, r2
		_system_clock_inst.dfll.mul =
    c56e:	4a0b      	ldr	r2, [pc, #44]	; (c59c <system_clock_source_dfll_set_config+0x74>)
    c570:	6093      	str	r3, [r2, #8]

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
    c572:	6811      	ldr	r1, [r2, #0]
    c574:	4b0b      	ldr	r3, [pc, #44]	; (c5a4 <system_clock_source_dfll_set_config+0x7c>)
    c576:	430b      	orrs	r3, r1
    c578:	6013      	str	r3, [r2, #0]
				SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
    c57a:	bd10      	pop	{r4, pc}
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    c57c:	7b03      	ldrb	r3, [r0, #12]
    c57e:	069b      	lsls	r3, r3, #26
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    c580:	8a02      	ldrh	r2, [r0, #16]
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    c582:	4313      	orrs	r3, r2
    c584:	89c2      	ldrh	r2, [r0, #14]
    c586:	0412      	lsls	r2, r2, #16
    c588:	4905      	ldr	r1, [pc, #20]	; (c5a0 <system_clock_source_dfll_set_config+0x78>)
    c58a:	400a      	ands	r2, r1
    c58c:	4313      	orrs	r3, r2
		_system_clock_inst.dfll.mul =
    c58e:	4a03      	ldr	r2, [pc, #12]	; (c59c <system_clock_source_dfll_set_config+0x74>)
    c590:	6093      	str	r3, [r2, #8]
		_system_clock_inst.dfll.control |= config->loop_mode;
    c592:	6813      	ldr	r3, [r2, #0]
    c594:	2104      	movs	r1, #4
    c596:	430b      	orrs	r3, r1
    c598:	6013      	str	r3, [r2, #0]
    c59a:	e7ee      	b.n	c57a <system_clock_source_dfll_set_config+0x52>
    c59c:	2000011c 	.word	0x2000011c
    c5a0:	03ff0000 	.word	0x03ff0000
    c5a4:	00000424 	.word	0x00000424

0000c5a8 <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    c5a8:	2808      	cmp	r0, #8
    c5aa:	d803      	bhi.n	c5b4 <system_clock_source_enable+0xc>
    c5ac:	0080      	lsls	r0, r0, #2
    c5ae:	4b25      	ldr	r3, [pc, #148]	; (c644 <system_clock_source_enable+0x9c>)
    c5b0:	581b      	ldr	r3, [r3, r0]
    c5b2:	469f      	mov	pc, r3
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    c5b4:	2017      	movs	r0, #23
    c5b6:	e044      	b.n	c642 <system_clock_source_enable+0x9a>
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    c5b8:	4a23      	ldr	r2, [pc, #140]	; (c648 <system_clock_source_enable+0xa0>)
    c5ba:	6a13      	ldr	r3, [r2, #32]
    c5bc:	2102      	movs	r1, #2
    c5be:	430b      	orrs	r3, r1
    c5c0:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
    c5c2:	2000      	movs	r0, #0
    c5c4:	e03d      	b.n	c642 <system_clock_source_enable+0x9a>
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    c5c6:	4a20      	ldr	r2, [pc, #128]	; (c648 <system_clock_source_enable+0xa0>)
    c5c8:	6993      	ldr	r3, [r2, #24]
    c5ca:	2102      	movs	r1, #2
    c5cc:	430b      	orrs	r3, r1
    c5ce:	6193      	str	r3, [r2, #24]
	}

	return STATUS_OK;
    c5d0:	2000      	movs	r0, #0
		break;
    c5d2:	e036      	b.n	c642 <system_clock_source_enable+0x9a>
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    c5d4:	4a1c      	ldr	r2, [pc, #112]	; (c648 <system_clock_source_enable+0xa0>)
    c5d6:	8a13      	ldrh	r3, [r2, #16]
    c5d8:	2102      	movs	r1, #2
    c5da:	430b      	orrs	r3, r1
    c5dc:	8213      	strh	r3, [r2, #16]
	return STATUS_OK;
    c5de:	2000      	movs	r0, #0
		break;
    c5e0:	e02f      	b.n	c642 <system_clock_source_enable+0x9a>
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    c5e2:	4a19      	ldr	r2, [pc, #100]	; (c648 <system_clock_source_enable+0xa0>)
    c5e4:	8a93      	ldrh	r3, [r2, #20]
    c5e6:	2102      	movs	r1, #2
    c5e8:	430b      	orrs	r3, r1
    c5ea:	8293      	strh	r3, [r2, #20]
	return STATUS_OK;
    c5ec:	2000      	movs	r0, #0
		break;
    c5ee:	e028      	b.n	c642 <system_clock_source_enable+0x9a>
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    c5f0:	4916      	ldr	r1, [pc, #88]	; (c64c <system_clock_source_enable+0xa4>)
    c5f2:	680b      	ldr	r3, [r1, #0]
    c5f4:	2202      	movs	r2, #2
    c5f6:	4313      	orrs	r3, r2
    c5f8:	600b      	str	r3, [r1, #0]
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    c5fa:	4b13      	ldr	r3, [pc, #76]	; (c648 <system_clock_source_enable+0xa0>)
    c5fc:	849a      	strh	r2, [r3, #36]	; 0x24
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    c5fe:	0019      	movs	r1, r3
    c600:	320e      	adds	r2, #14
    c602:	68cb      	ldr	r3, [r1, #12]
    c604:	421a      	tst	r2, r3
    c606:	d0fc      	beq.n	c602 <system_clock_source_enable+0x5a>
	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    c608:	4a10      	ldr	r2, [pc, #64]	; (c64c <system_clock_source_enable+0xa4>)
    c60a:	6891      	ldr	r1, [r2, #8]
    c60c:	4b0e      	ldr	r3, [pc, #56]	; (c648 <system_clock_source_enable+0xa0>)
    c60e:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    c610:	6852      	ldr	r2, [r2, #4]
    c612:	629a      	str	r2, [r3, #40]	; 0x28
	SYSCTRL->DFLLCTRL.reg = 0;
    c614:	2200      	movs	r2, #0
    c616:	849a      	strh	r2, [r3, #36]	; 0x24
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    c618:	0019      	movs	r1, r3
    c61a:	3210      	adds	r2, #16
    c61c:	68cb      	ldr	r3, [r1, #12]
    c61e:	421a      	tst	r2, r3
    c620:	d0fc      	beq.n	c61c <system_clock_source_enable+0x74>
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    c622:	4b0a      	ldr	r3, [pc, #40]	; (c64c <system_clock_source_enable+0xa4>)
    c624:	681b      	ldr	r3, [r3, #0]
    c626:	b29b      	uxth	r3, r3
    c628:	4a07      	ldr	r2, [pc, #28]	; (c648 <system_clock_source_enable+0xa0>)
    c62a:	8493      	strh	r3, [r2, #36]	; 0x24
	return STATUS_OK;
    c62c:	2000      	movs	r0, #0
    c62e:	e008      	b.n	c642 <system_clock_source_enable+0x9a>
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    c630:	4905      	ldr	r1, [pc, #20]	; (c648 <system_clock_source_enable+0xa0>)
    c632:	2244      	movs	r2, #68	; 0x44
    c634:	5c8b      	ldrb	r3, [r1, r2]
    c636:	2002      	movs	r0, #2
    c638:	4303      	orrs	r3, r0
    c63a:	548b      	strb	r3, [r1, r2]
	return STATUS_OK;
    c63c:	2000      	movs	r0, #0
		break;
    c63e:	e000      	b.n	c642 <system_clock_source_enable+0x9a>
		return STATUS_OK;
    c640:	2000      	movs	r0, #0
}
    c642:	4770      	bx	lr
    c644:	0000d254 	.word	0x0000d254
    c648:	40000800 	.word	0x40000800
    c64c:	2000011c 	.word	0x2000011c

0000c650 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    c650:	b5f0      	push	{r4, r5, r6, r7, lr}
    c652:	b08f      	sub	sp, #60	; 0x3c
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    c654:	22c2      	movs	r2, #194	; 0xc2
    c656:	00d2      	lsls	r2, r2, #3
    c658:	4b45      	ldr	r3, [pc, #276]	; (c770 <system_clock_init+0x120>)
    c65a:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    c65c:	4a45      	ldr	r2, [pc, #276]	; (c774 <system_clock_init+0x124>)
    c65e:	6853      	ldr	r3, [r2, #4]
    c660:	211e      	movs	r1, #30
    c662:	438b      	bics	r3, r1
    c664:	391a      	subs	r1, #26
    c666:	430b      	orrs	r3, r1
    c668:	6053      	str	r3, [r2, #4]
	gclk_conf.source_generator = GCLK_GENERATOR_2;
    c66a:	2202      	movs	r2, #2
    c66c:	ab01      	add	r3, sp, #4
    c66e:	701a      	strb	r2, [r3, #0]
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    c670:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    c672:	4d41      	ldr	r5, [pc, #260]	; (c778 <system_clock_init+0x128>)
    c674:	b2e0      	uxtb	r0, r4
    c676:	a901      	add	r1, sp, #4
    c678:	47a8      	blx	r5
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    c67a:	3401      	adds	r4, #1
    c67c:	2c25      	cmp	r4, #37	; 0x25
    c67e:	d1f9      	bne.n	c674 <system_clock_init+0x24>
	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    c680:	a80a      	add	r0, sp, #40	; 0x28
    c682:	2300      	movs	r3, #0
    c684:	7003      	strb	r3, [r0, #0]
	config->auto_gain_control   = false;
    c686:	7083      	strb	r3, [r0, #2]
	config->frequency           = 32768UL;
    c688:	2280      	movs	r2, #128	; 0x80
    c68a:	0212      	lsls	r2, r2, #8
    c68c:	6082      	str	r2, [r0, #8]
	config->enable_1khz_output  = false;
    c68e:	70c3      	strb	r3, [r0, #3]
	config->enable_32khz_output = true;
    c690:	2201      	movs	r2, #1
    c692:	7102      	strb	r2, [r0, #4]
	config->write_once          = false;
    c694:	7383      	strb	r3, [r0, #14]
	struct system_clock_source_xosc32k_config xosc32k_conf;
	system_clock_source_xosc32k_get_config_defaults(&xosc32k_conf);

	xosc32k_conf.frequency           = 32768UL;
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
    c696:	2106      	movs	r1, #6
    c698:	7041      	strb	r1, [r0, #1]
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
    c69a:	7343      	strb	r3, [r0, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
    c69c:	7302      	strb	r2, [r0, #12]

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
    c69e:	4b37      	ldr	r3, [pc, #220]	; (c77c <system_clock_init+0x12c>)
    c6a0:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
    c6a2:	2005      	movs	r0, #5
    c6a4:	4b36      	ldr	r3, [pc, #216]	; (c780 <system_clock_init+0x130>)
    c6a6:	4798      	blx	r3
	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    c6a8:	4931      	ldr	r1, [pc, #196]	; (c770 <system_clock_init+0x120>)
    c6aa:	2202      	movs	r2, #2
    c6ac:	68cb      	ldr	r3, [r1, #12]
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    c6ae:	421a      	tst	r2, r3
    c6b0:	d0fc      	beq.n	c6ac <system_clock_init+0x5c>
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    c6b2:	ab05      	add	r3, sp, #20
    c6b4:	2100      	movs	r1, #0
    c6b6:	2200      	movs	r2, #0
    c6b8:	8059      	strh	r1, [r3, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    c6ba:	8099      	strh	r1, [r3, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    c6bc:	719a      	strb	r2, [r3, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    c6be:	71da      	strb	r2, [r3, #7]
	config->fine_value      = 0xff / 4; /* Midpoint */
    c6c0:	313f      	adds	r1, #63	; 0x3f
    c6c2:	8159      	strh	r1, [r3, #10]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    c6c4:	393b      	subs	r1, #59	; 0x3b
    c6c6:	7019      	strb	r1, [r3, #0]
	dfll_conf.on_demand      = false;
    c6c8:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping
	   in DFLL.COARSE helps to output a frequency close to 48 MHz.*/
#define NVM_DFLL_COARSE_POS    58 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

	uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
    c6ca:	4b2e      	ldr	r3, [pc, #184]	; (c784 <system_clock_init+0x134>)
    c6cc:	681b      	ldr	r3, [r3, #0]
    c6ce:	0e9b      	lsrs	r3, r3, #26
			+ (NVM_DFLL_COARSE_POS / 32))
		>> (NVM_DFLL_COARSE_POS % 32))
		& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
	/* In some revision chip, the coarse calibration value is not correct. */
	if (coarse == 0x3f) {
    c6d0:	2b3f      	cmp	r3, #63	; 0x3f
    c6d2:	d04b      	beq.n	c76c <system_clock_init+0x11c>
		coarse = 0x1f;
	}
	dfll_conf.coarse_value = coarse;
    c6d4:	a805      	add	r0, sp, #20
    c6d6:	7203      	strb	r3, [r0, #8]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    c6d8:	23b7      	movs	r3, #183	; 0xb7
    c6da:	00db      	lsls	r3, r3, #3
    c6dc:	8203      	strh	r3, [r0, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    c6de:	2303      	movs	r3, #3
    c6e0:	7303      	strb	r3, [r0, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    c6e2:	331c      	adds	r3, #28
    c6e4:	81c3      	strh	r3, [r0, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
    c6e6:	4b28      	ldr	r3, [pc, #160]	; (c788 <system_clock_init+0x138>)
    c6e8:	4798      	blx	r3
	config->on_demand       = true;
    c6ea:	a804      	add	r0, sp, #16
    c6ec:	2501      	movs	r5, #1
    c6ee:	7085      	strb	r5, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    c6f0:	2600      	movs	r6, #0
    c6f2:	7006      	strb	r6, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;
    c6f4:	7045      	strb	r5, [r0, #1]

	system_clock_source_osc8m_set_config(&osc8m_conf);
    c6f6:	4b25      	ldr	r3, [pc, #148]	; (c78c <system_clock_init+0x13c>)
    c6f8:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    c6fa:	2006      	movs	r0, #6
    c6fc:	4f20      	ldr	r7, [pc, #128]	; (c780 <system_clock_init+0x130>)
    c6fe:	47b8      	blx	r7


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    c700:	4b23      	ldr	r3, [pc, #140]	; (c790 <system_clock_init+0x140>)
    c702:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    c704:	ac01      	add	r4, sp, #4
    c706:	9502      	str	r5, [sp, #8]
	config->high_when_disabled = false;
    c708:	7066      	strb	r6, [r4, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    c70a:	7226      	strb	r6, [r4, #8]
	config->output_enable      = false;
    c70c:	7266      	strb	r6, [r4, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    c70e:	2305      	movs	r3, #5
    c710:	7023      	strb	r3, [r4, #0]
    c712:	0021      	movs	r1, r4
    c714:	2001      	movs	r0, #1
    c716:	4b1f      	ldr	r3, [pc, #124]	; (c794 <system_clock_init+0x144>)
    c718:	4798      	blx	r3
    c71a:	2001      	movs	r0, #1
    c71c:	4b1e      	ldr	r3, [pc, #120]	; (c798 <system_clock_init+0x148>)
    c71e:	4798      	blx	r3
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    c720:	7025      	strb	r5, [r4, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    c722:	0021      	movs	r1, r4
    c724:	2000      	movs	r0, #0
    c726:	4b14      	ldr	r3, [pc, #80]	; (c778 <system_clock_init+0x128>)
    c728:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
    c72a:	2000      	movs	r0, #0
    c72c:	4b1b      	ldr	r3, [pc, #108]	; (c79c <system_clock_init+0x14c>)
    c72e:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    c730:	2007      	movs	r0, #7
    c732:	47b8      	blx	r7
	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    c734:	490e      	ldr	r1, [pc, #56]	; (c770 <system_clock_init+0x120>)
    c736:	22d0      	movs	r2, #208	; 0xd0
    c738:	68cb      	ldr	r3, [r1, #12]
    c73a:	4013      	ands	r3, r2
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    c73c:	2bd0      	cmp	r3, #208	; 0xd0
    c73e:	d1fb      	bne.n	c738 <system_clock_init+0xe8>
	PM->CPUSEL.reg = (uint32_t)divider;
    c740:	4a17      	ldr	r2, [pc, #92]	; (c7a0 <system_clock_init+0x150>)
    c742:	2300      	movs	r3, #0
    c744:	7213      	strb	r3, [r2, #8]
			PM->APBASEL.reg = (uint32_t)divider;
    c746:	7253      	strb	r3, [r2, #9]
			PM->APBBSEL.reg = (uint32_t)divider;
    c748:	7293      	strb	r3, [r2, #10]
			PM->APBCSEL.reg = (uint32_t)divider;
    c74a:	72d3      	strb	r3, [r2, #11]
	config->division_factor    = 1;
    c74c:	a901      	add	r1, sp, #4
    c74e:	2201      	movs	r2, #1
    c750:	604a      	str	r2, [r1, #4]
	config->high_when_disabled = false;
    c752:	704b      	strb	r3, [r1, #1]
	config->output_enable      = false;
    c754:	724b      	strb	r3, [r1, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    c756:	3307      	adds	r3, #7
    c758:	700b      	strb	r3, [r1, #0]
    c75a:	720a      	strb	r2, [r1, #8]
    c75c:	2000      	movs	r0, #0
    c75e:	4b0d      	ldr	r3, [pc, #52]	; (c794 <system_clock_init+0x144>)
    c760:	4798      	blx	r3
    c762:	2000      	movs	r0, #0
    c764:	4b0c      	ldr	r3, [pc, #48]	; (c798 <system_clock_init+0x148>)
    c766:	4798      	blx	r3
#endif
}
    c768:	b00f      	add	sp, #60	; 0x3c
    c76a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		coarse = 0x1f;
    c76c:	3b20      	subs	r3, #32
    c76e:	e7b1      	b.n	c6d4 <system_clock_init+0x84>
    c770:	40000800 	.word	0x40000800
    c774:	41004000 	.word	0x41004000
    c778:	0000c9dd 	.word	0x0000c9dd
    c77c:	0000c471 	.word	0x0000c471
    c780:	0000c5a9 	.word	0x0000c5a9
    c784:	00806024 	.word	0x00806024
    c788:	0000c529 	.word	0x0000c529
    c78c:	0000c435 	.word	0x0000c435
    c790:	0000c7a5 	.word	0x0000c7a5
    c794:	0000c7c9 	.word	0x0000c7c9
    c798:	0000c881 	.word	0x0000c881
    c79c:	0000c951 	.word	0x0000c951
    c7a0:	40000400 	.word	0x40000400

0000c7a4 <system_gclk_init>:
			PM->APBAMASK.reg |= mask;
    c7a4:	4a06      	ldr	r2, [pc, #24]	; (c7c0 <system_gclk_init+0x1c>)
    c7a6:	6993      	ldr	r3, [r2, #24]
    c7a8:	2108      	movs	r1, #8
    c7aa:	430b      	orrs	r3, r1
    c7ac:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    c7ae:	2201      	movs	r2, #1
    c7b0:	4b04      	ldr	r3, [pc, #16]	; (c7c4 <system_gclk_init+0x20>)
    c7b2:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    c7b4:	0019      	movs	r1, r3
    c7b6:	780b      	ldrb	r3, [r1, #0]
    c7b8:	4213      	tst	r3, r2
    c7ba:	d1fc      	bne.n	c7b6 <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    c7bc:	4770      	bx	lr
    c7be:	46c0      	nop			; (mov r8, r8)
    c7c0:	40000400 	.word	0x40000400
    c7c4:	40000c00 	.word	0x40000c00

0000c7c8 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    c7c8:	b570      	push	{r4, r5, r6, lr}
    c7ca:	0006      	movs	r6, r0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    c7cc:	0004      	movs	r4, r0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    c7ce:	780d      	ldrb	r5, [r1, #0]
    c7d0:	022d      	lsls	r5, r5, #8
    c7d2:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    c7d4:	784b      	ldrb	r3, [r1, #1]
    c7d6:	2b00      	cmp	r3, #0
    c7d8:	d002      	beq.n	c7e0 <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    c7da:	2380      	movs	r3, #128	; 0x80
    c7dc:	02db      	lsls	r3, r3, #11
    c7de:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    c7e0:	7a4b      	ldrb	r3, [r1, #9]
    c7e2:	2b00      	cmp	r3, #0
    c7e4:	d002      	beq.n	c7ec <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    c7e6:	2380      	movs	r3, #128	; 0x80
    c7e8:	031b      	lsls	r3, r3, #12
    c7ea:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    c7ec:	6848      	ldr	r0, [r1, #4]
    c7ee:	2801      	cmp	r0, #1
    c7f0:	d910      	bls.n	c814 <system_gclk_gen_set_config+0x4c>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    c7f2:	1e43      	subs	r3, r0, #1
    c7f4:	4218      	tst	r0, r3
    c7f6:	d134      	bne.n	c862 <system_gclk_gen_set_config+0x9a>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    c7f8:	2802      	cmp	r0, #2
    c7fa:	d930      	bls.n	c85e <system_gclk_gen_set_config+0x96>
    c7fc:	2302      	movs	r3, #2
    c7fe:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
    c800:	3201      	adds	r2, #1
						mask <<= 1) {
    c802:	005b      	lsls	r3, r3, #1
			for (mask = (1UL << 1); mask < config->division_factor;
    c804:	4298      	cmp	r0, r3
    c806:	d8fb      	bhi.n	c800 <system_gclk_gen_set_config+0x38>
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    c808:	0212      	lsls	r2, r2, #8
    c80a:	4332      	orrs	r2, r6
    c80c:	0014      	movs	r4, r2
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    c80e:	2380      	movs	r3, #128	; 0x80
    c810:	035b      	lsls	r3, r3, #13
    c812:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    c814:	7a0b      	ldrb	r3, [r1, #8]
    c816:	2b00      	cmp	r3, #0
    c818:	d002      	beq.n	c820 <system_gclk_gen_set_config+0x58>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    c81a:	2380      	movs	r3, #128	; 0x80
    c81c:	039b      	lsls	r3, r3, #14
    c81e:	431d      	orrs	r5, r3
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    c820:	4a13      	ldr	r2, [pc, #76]	; (c870 <system_gclk_gen_set_config+0xa8>)
    c822:	7853      	ldrb	r3, [r2, #1]
	}

	while (system_gclk_is_syncing()) {
    c824:	b25b      	sxtb	r3, r3
    c826:	2b00      	cmp	r3, #0
    c828:	dbfb      	blt.n	c822 <system_gclk_gen_set_config+0x5a>
	cpu_irq_enter_critical();
    c82a:	4b12      	ldr	r3, [pc, #72]	; (c874 <system_gclk_gen_set_config+0xac>)
    c82c:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    c82e:	4b12      	ldr	r3, [pc, #72]	; (c878 <system_gclk_gen_set_config+0xb0>)
    c830:	701e      	strb	r6, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    c832:	4a0f      	ldr	r2, [pc, #60]	; (c870 <system_gclk_gen_set_config+0xa8>)
    c834:	7853      	ldrb	r3, [r2, #1]

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    c836:	b25b      	sxtb	r3, r3
    c838:	2b00      	cmp	r3, #0
    c83a:	dbfb      	blt.n	c834 <system_gclk_gen_set_config+0x6c>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    c83c:	4b0c      	ldr	r3, [pc, #48]	; (c870 <system_gclk_gen_set_config+0xa8>)
    c83e:	609c      	str	r4, [r3, #8]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    c840:	001a      	movs	r2, r3
    c842:	7853      	ldrb	r3, [r2, #1]

	while (system_gclk_is_syncing()) {
    c844:	b25b      	sxtb	r3, r3
    c846:	2b00      	cmp	r3, #0
    c848:	dbfb      	blt.n	c842 <system_gclk_gen_set_config+0x7a>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    c84a:	4a09      	ldr	r2, [pc, #36]	; (c870 <system_gclk_gen_set_config+0xa8>)
    c84c:	6853      	ldr	r3, [r2, #4]
    c84e:	2180      	movs	r1, #128	; 0x80
    c850:	0249      	lsls	r1, r1, #9
    c852:	400b      	ands	r3, r1
    c854:	431d      	orrs	r5, r3
    c856:	6055      	str	r5, [r2, #4]
	cpu_irq_leave_critical();
    c858:	4b08      	ldr	r3, [pc, #32]	; (c87c <system_gclk_gen_set_config+0xb4>)
    c85a:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    c85c:	bd70      	pop	{r4, r5, r6, pc}
			for (mask = (1UL << 1); mask < config->division_factor;
    c85e:	2200      	movs	r2, #0
    c860:	e7d2      	b.n	c808 <system_gclk_gen_set_config+0x40>
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    c862:	0204      	lsls	r4, r0, #8
			new_gendiv_config  |=
    c864:	4334      	orrs	r4, r6
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    c866:	2380      	movs	r3, #128	; 0x80
    c868:	029b      	lsls	r3, r3, #10
    c86a:	431d      	orrs	r5, r3
    c86c:	e7d2      	b.n	c814 <system_gclk_gen_set_config+0x4c>
    c86e:	46c0      	nop			; (mov r8, r8)
    c870:	40000c00 	.word	0x40000c00
    c874:	0000b549 	.word	0x0000b549
    c878:	40000c08 	.word	0x40000c08
    c87c:	0000b589 	.word	0x0000b589

0000c880 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    c880:	b510      	push	{r4, lr}
    c882:	0004      	movs	r4, r0
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    c884:	4a0b      	ldr	r2, [pc, #44]	; (c8b4 <system_gclk_gen_enable+0x34>)
    c886:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    c888:	b25b      	sxtb	r3, r3
    c88a:	2b00      	cmp	r3, #0
    c88c:	dbfb      	blt.n	c886 <system_gclk_gen_enable+0x6>
	cpu_irq_enter_critical();
    c88e:	4b0a      	ldr	r3, [pc, #40]	; (c8b8 <system_gclk_gen_enable+0x38>)
    c890:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    c892:	4b0a      	ldr	r3, [pc, #40]	; (c8bc <system_gclk_gen_enable+0x3c>)
    c894:	701c      	strb	r4, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    c896:	4a07      	ldr	r2, [pc, #28]	; (c8b4 <system_gclk_gen_enable+0x34>)
    c898:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    c89a:	b25b      	sxtb	r3, r3
    c89c:	2b00      	cmp	r3, #0
    c89e:	dbfb      	blt.n	c898 <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    c8a0:	4a04      	ldr	r2, [pc, #16]	; (c8b4 <system_gclk_gen_enable+0x34>)
    c8a2:	6851      	ldr	r1, [r2, #4]
    c8a4:	2380      	movs	r3, #128	; 0x80
    c8a6:	025b      	lsls	r3, r3, #9
    c8a8:	430b      	orrs	r3, r1
    c8aa:	6053      	str	r3, [r2, #4]
	cpu_irq_leave_critical();
    c8ac:	4b04      	ldr	r3, [pc, #16]	; (c8c0 <system_gclk_gen_enable+0x40>)
    c8ae:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    c8b0:	bd10      	pop	{r4, pc}
    c8b2:	46c0      	nop			; (mov r8, r8)
    c8b4:	40000c00 	.word	0x40000c00
    c8b8:	0000b549 	.word	0x0000b549
    c8bc:	40000c04 	.word	0x40000c04
    c8c0:	0000b589 	.word	0x0000b589

0000c8c4 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    c8c4:	b570      	push	{r4, r5, r6, lr}
    c8c6:	0004      	movs	r4, r0
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    c8c8:	4a1a      	ldr	r2, [pc, #104]	; (c934 <system_gclk_gen_get_hz+0x70>)
    c8ca:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    c8cc:	b25b      	sxtb	r3, r3
    c8ce:	2b00      	cmp	r3, #0
    c8d0:	dbfb      	blt.n	c8ca <system_gclk_gen_get_hz+0x6>
	cpu_irq_enter_critical();
    c8d2:	4b19      	ldr	r3, [pc, #100]	; (c938 <system_gclk_gen_get_hz+0x74>)
    c8d4:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    c8d6:	4b19      	ldr	r3, [pc, #100]	; (c93c <system_gclk_gen_get_hz+0x78>)
    c8d8:	701c      	strb	r4, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    c8da:	4a16      	ldr	r2, [pc, #88]	; (c934 <system_gclk_gen_get_hz+0x70>)
    c8dc:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    c8de:	b25b      	sxtb	r3, r3
    c8e0:	2b00      	cmp	r3, #0
    c8e2:	dbfb      	blt.n	c8dc <system_gclk_gen_get_hz+0x18>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    c8e4:	4e13      	ldr	r6, [pc, #76]	; (c934 <system_gclk_gen_get_hz+0x70>)
    c8e6:	6870      	ldr	r0, [r6, #4]
    c8e8:	04c0      	lsls	r0, r0, #19
    c8ea:	0ec0      	lsrs	r0, r0, #27
	uint32_t gen_input_hz = system_clock_source_get_hz(
    c8ec:	4b14      	ldr	r3, [pc, #80]	; (c940 <system_gclk_gen_get_hz+0x7c>)
    c8ee:	4798      	blx	r3
    c8f0:	0005      	movs	r5, r0

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    c8f2:	4b12      	ldr	r3, [pc, #72]	; (c93c <system_gclk_gen_get_hz+0x78>)
    c8f4:	701c      	strb	r4, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    c8f6:	6876      	ldr	r6, [r6, #4]
    c8f8:	02f6      	lsls	r6, r6, #11
    c8fa:	0ff6      	lsrs	r6, r6, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    c8fc:	4b11      	ldr	r3, [pc, #68]	; (c944 <system_gclk_gen_get_hz+0x80>)
    c8fe:	701c      	strb	r4, [r3, #0]
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    c900:	4a0c      	ldr	r2, [pc, #48]	; (c934 <system_gclk_gen_get_hz+0x70>)
    c902:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
    c904:	b25b      	sxtb	r3, r3
    c906:	2b00      	cmp	r3, #0
    c908:	dbfb      	blt.n	c902 <system_gclk_gen_get_hz+0x3e>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    c90a:	4b0a      	ldr	r3, [pc, #40]	; (c934 <system_gclk_gen_get_hz+0x70>)
    c90c:	689c      	ldr	r4, [r3, #8]
    c90e:	0224      	lsls	r4, r4, #8
    c910:	0c24      	lsrs	r4, r4, #16
	cpu_irq_leave_critical();
    c912:	4b0d      	ldr	r3, [pc, #52]	; (c948 <system_gclk_gen_get_hz+0x84>)
    c914:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    c916:	2e00      	cmp	r6, #0
    c918:	d107      	bne.n	c92a <system_gclk_gen_get_hz+0x66>
    c91a:	2c01      	cmp	r4, #1
    c91c:	d907      	bls.n	c92e <system_gclk_gen_get_hz+0x6a>
		gen_input_hz /= divider;
    c91e:	0021      	movs	r1, r4
    c920:	0028      	movs	r0, r5
    c922:	4b0a      	ldr	r3, [pc, #40]	; (c94c <system_gclk_gen_get_hz+0x88>)
    c924:	4798      	blx	r3
    c926:	0005      	movs	r5, r0
    c928:	e001      	b.n	c92e <system_gclk_gen_get_hz+0x6a>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    c92a:	3401      	adds	r4, #1
    c92c:	40e5      	lsrs	r5, r4
	}

	return gen_input_hz;
}
    c92e:	0028      	movs	r0, r5
    c930:	bd70      	pop	{r4, r5, r6, pc}
    c932:	46c0      	nop			; (mov r8, r8)
    c934:	40000c00 	.word	0x40000c00
    c938:	0000b549 	.word	0x0000b549
    c93c:	40000c04 	.word	0x40000c04
    c940:	0000c3a1 	.word	0x0000c3a1
    c944:	40000c08 	.word	0x40000c08
    c948:	0000b589 	.word	0x0000b589
    c94c:	0000cd39 	.word	0x0000cd39

0000c950 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    c950:	b510      	push	{r4, lr}
    c952:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
    c954:	4b06      	ldr	r3, [pc, #24]	; (c970 <system_gclk_chan_enable+0x20>)
    c956:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    c958:	4b06      	ldr	r3, [pc, #24]	; (c974 <system_gclk_chan_enable+0x24>)
    c95a:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    c95c:	4a06      	ldr	r2, [pc, #24]	; (c978 <system_gclk_chan_enable+0x28>)
    c95e:	8853      	ldrh	r3, [r2, #2]
    c960:	2180      	movs	r1, #128	; 0x80
    c962:	01c9      	lsls	r1, r1, #7
    c964:	430b      	orrs	r3, r1
    c966:	8053      	strh	r3, [r2, #2]
	cpu_irq_leave_critical();
    c968:	4b04      	ldr	r3, [pc, #16]	; (c97c <system_gclk_chan_enable+0x2c>)
    c96a:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    c96c:	bd10      	pop	{r4, pc}
    c96e:	46c0      	nop			; (mov r8, r8)
    c970:	0000b549 	.word	0x0000b549
    c974:	40000c02 	.word	0x40000c02
    c978:	40000c00 	.word	0x40000c00
    c97c:	0000b589 	.word	0x0000b589

0000c980 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    c980:	b510      	push	{r4, lr}
    c982:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
    c984:	4b0f      	ldr	r3, [pc, #60]	; (c9c4 <system_gclk_chan_disable+0x44>)
    c986:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    c988:	4b0f      	ldr	r3, [pc, #60]	; (c9c8 <system_gclk_chan_disable+0x48>)
    c98a:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    c98c:	4a0f      	ldr	r2, [pc, #60]	; (c9cc <system_gclk_chan_disable+0x4c>)
    c98e:	8853      	ldrh	r3, [r2, #2]
    c990:	051b      	lsls	r3, r3, #20
    c992:	0f18      	lsrs	r0, r3, #28
	GCLK->CLKCTRL.bit.GEN = 0;
    c994:	8853      	ldrh	r3, [r2, #2]
    c996:	490e      	ldr	r1, [pc, #56]	; (c9d0 <system_gclk_chan_disable+0x50>)
    c998:	400b      	ands	r3, r1
    c99a:	8053      	strh	r3, [r2, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    c99c:	8853      	ldrh	r3, [r2, #2]
    c99e:	490d      	ldr	r1, [pc, #52]	; (c9d4 <system_gclk_chan_disable+0x54>)
    c9a0:	400b      	ands	r3, r1
    c9a2:	8053      	strh	r3, [r2, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    c9a4:	0011      	movs	r1, r2
    c9a6:	2280      	movs	r2, #128	; 0x80
    c9a8:	01d2      	lsls	r2, r2, #7
    c9aa:	884b      	ldrh	r3, [r1, #2]
    c9ac:	4213      	tst	r3, r2
    c9ae:	d1fc      	bne.n	c9aa <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    c9b0:	4906      	ldr	r1, [pc, #24]	; (c9cc <system_gclk_chan_disable+0x4c>)
    c9b2:	884a      	ldrh	r2, [r1, #2]
    c9b4:	0203      	lsls	r3, r0, #8
    c9b6:	4806      	ldr	r0, [pc, #24]	; (c9d0 <system_gclk_chan_disable+0x50>)
    c9b8:	4002      	ands	r2, r0
    c9ba:	4313      	orrs	r3, r2
    c9bc:	804b      	strh	r3, [r1, #2]
	cpu_irq_leave_critical();
    c9be:	4b06      	ldr	r3, [pc, #24]	; (c9d8 <system_gclk_chan_disable+0x58>)
    c9c0:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    c9c2:	bd10      	pop	{r4, pc}
    c9c4:	0000b549 	.word	0x0000b549
    c9c8:	40000c02 	.word	0x40000c02
    c9cc:	40000c00 	.word	0x40000c00
    c9d0:	fffff0ff 	.word	0xfffff0ff
    c9d4:	ffffbfff 	.word	0xffffbfff
    c9d8:	0000b589 	.word	0x0000b589

0000c9dc <system_gclk_chan_set_config>:
{
    c9dc:	b510      	push	{r4, lr}
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    c9de:	780c      	ldrb	r4, [r1, #0]
    c9e0:	0224      	lsls	r4, r4, #8
    c9e2:	4304      	orrs	r4, r0
	system_gclk_chan_disable(channel);
    c9e4:	4b02      	ldr	r3, [pc, #8]	; (c9f0 <system_gclk_chan_set_config+0x14>)
    c9e6:	4798      	blx	r3
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    c9e8:	b2a4      	uxth	r4, r4
    c9ea:	4b02      	ldr	r3, [pc, #8]	; (c9f4 <system_gclk_chan_set_config+0x18>)
    c9ec:	805c      	strh	r4, [r3, #2]
}
    c9ee:	bd10      	pop	{r4, pc}
    c9f0:	0000c981 	.word	0x0000c981
    c9f4:	40000c00 	.word	0x40000c00

0000c9f8 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    c9f8:	b510      	push	{r4, lr}
    c9fa:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
    c9fc:	4b06      	ldr	r3, [pc, #24]	; (ca18 <system_gclk_chan_get_hz+0x20>)
    c9fe:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    ca00:	4b06      	ldr	r3, [pc, #24]	; (ca1c <system_gclk_chan_get_hz+0x24>)
    ca02:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    ca04:	4b06      	ldr	r3, [pc, #24]	; (ca20 <system_gclk_chan_get_hz+0x28>)
    ca06:	885c      	ldrh	r4, [r3, #2]
    ca08:	0524      	lsls	r4, r4, #20
    ca0a:	0f24      	lsrs	r4, r4, #28
	cpu_irq_leave_critical();
    ca0c:	4b05      	ldr	r3, [pc, #20]	; (ca24 <system_gclk_chan_get_hz+0x2c>)
    ca0e:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    ca10:	0020      	movs	r0, r4
    ca12:	4b05      	ldr	r3, [pc, #20]	; (ca28 <system_gclk_chan_get_hz+0x30>)
    ca14:	4798      	blx	r3
}
    ca16:	bd10      	pop	{r4, pc}
    ca18:	0000b549 	.word	0x0000b549
    ca1c:	40000c02 	.word	0x40000c02
    ca20:	40000c00 	.word	0x40000c00
    ca24:	0000b589 	.word	0x0000b589
    ca28:	0000c8c5 	.word	0x0000c8c5

0000ca2c <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    ca2c:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    ca2e:	78d3      	ldrb	r3, [r2, #3]
    ca30:	2b00      	cmp	r3, #0
    ca32:	d135      	bne.n	caa0 <_system_pinmux_config+0x74>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    ca34:	7813      	ldrb	r3, [r2, #0]
    ca36:	2b80      	cmp	r3, #128	; 0x80
    ca38:	d029      	beq.n	ca8e <_system_pinmux_config+0x62>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    ca3a:	061b      	lsls	r3, r3, #24
    ca3c:	2480      	movs	r4, #128	; 0x80
    ca3e:	0264      	lsls	r4, r4, #9
    ca40:	4323      	orrs	r3, r4
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    ca42:	7854      	ldrb	r4, [r2, #1]
    ca44:	2502      	movs	r5, #2
    ca46:	43ac      	bics	r4, r5
    ca48:	d106      	bne.n	ca58 <_system_pinmux_config+0x2c>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    ca4a:	7894      	ldrb	r4, [r2, #2]
    ca4c:	2c00      	cmp	r4, #0
    ca4e:	d120      	bne.n	ca92 <_system_pinmux_config+0x66>
			pin_cfg |= PORT_WRCONFIG_INEN;
    ca50:	2480      	movs	r4, #128	; 0x80
    ca52:	02a4      	lsls	r4, r4, #10
    ca54:	4323      	orrs	r3, r4
				pin_cfg |= PORT_WRCONFIG_PULLEN;
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    ca56:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    ca58:	7854      	ldrb	r4, [r2, #1]
    ca5a:	3c01      	subs	r4, #1
    ca5c:	2c01      	cmp	r4, #1
    ca5e:	d91c      	bls.n	ca9a <_system_pinmux_config+0x6e>
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    ca60:	040d      	lsls	r5, r1, #16
    ca62:	0c2d      	lsrs	r5, r5, #16

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    ca64:	24a0      	movs	r4, #160	; 0xa0
    ca66:	05e4      	lsls	r4, r4, #23
    ca68:	432c      	orrs	r4, r5
    ca6a:	431c      	orrs	r4, r3
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    ca6c:	6284      	str	r4, [r0, #40]	; 0x28
	uint32_t upper_pin_mask = (pin_mask >> 16);
    ca6e:	0c0d      	lsrs	r5, r1, #16

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    ca70:	24d0      	movs	r4, #208	; 0xd0
    ca72:	0624      	lsls	r4, r4, #24
    ca74:	432c      	orrs	r4, r5
    ca76:	431c      	orrs	r4, r3
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    ca78:	6284      	str	r4, [r0, #40]	; 0x28
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    ca7a:	78d4      	ldrb	r4, [r2, #3]
    ca7c:	2c00      	cmp	r4, #0
    ca7e:	d122      	bne.n	cac6 <_system_pinmux_config+0x9a>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    ca80:	035b      	lsls	r3, r3, #13
    ca82:	d51c      	bpl.n	cabe <_system_pinmux_config+0x92>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    ca84:	7893      	ldrb	r3, [r2, #2]
    ca86:	2b01      	cmp	r3, #1
    ca88:	d01e      	beq.n	cac8 <_system_pinmux_config+0x9c>
				port->OUTSET.reg = pin_mask;
			} else {
				port->OUTCLR.reg = pin_mask;
    ca8a:	6141      	str	r1, [r0, #20]
    ca8c:	e017      	b.n	cabe <_system_pinmux_config+0x92>
	uint32_t pin_cfg = 0;
    ca8e:	2300      	movs	r3, #0
    ca90:	e7d7      	b.n	ca42 <_system_pinmux_config+0x16>
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    ca92:	24c0      	movs	r4, #192	; 0xc0
    ca94:	02e4      	lsls	r4, r4, #11
    ca96:	4323      	orrs	r3, r4
    ca98:	e7dd      	b.n	ca56 <_system_pinmux_config+0x2a>
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    ca9a:	4c0d      	ldr	r4, [pc, #52]	; (cad0 <_system_pinmux_config+0xa4>)
    ca9c:	4023      	ands	r3, r4
    ca9e:	e7df      	b.n	ca60 <_system_pinmux_config+0x34>
		port->DIRCLR.reg = pin_mask;
    caa0:	6041      	str	r1, [r0, #4]
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    caa2:	040c      	lsls	r4, r1, #16
    caa4:	0c24      	lsrs	r4, r4, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    caa6:	23a0      	movs	r3, #160	; 0xa0
    caa8:	05db      	lsls	r3, r3, #23
    caaa:	4323      	orrs	r3, r4
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    caac:	6283      	str	r3, [r0, #40]	; 0x28
	uint32_t upper_pin_mask = (pin_mask >> 16);
    caae:	0c0c      	lsrs	r4, r1, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    cab0:	23d0      	movs	r3, #208	; 0xd0
    cab2:	061b      	lsls	r3, r3, #24
    cab4:	4323      	orrs	r3, r4
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    cab6:	6283      	str	r3, [r0, #40]	; 0x28
	if(!config->powersave) {
    cab8:	78d3      	ldrb	r3, [r2, #3]
    caba:	2b00      	cmp	r3, #0
    cabc:	d103      	bne.n	cac6 <_system_pinmux_config+0x9a>
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    cabe:	7853      	ldrb	r3, [r2, #1]
    cac0:	3b01      	subs	r3, #1
    cac2:	2b01      	cmp	r3, #1
    cac4:	d902      	bls.n	cacc <_system_pinmux_config+0xa0>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
		}
	}
}
    cac6:	bd30      	pop	{r4, r5, pc}
				port->OUTSET.reg = pin_mask;
    cac8:	6181      	str	r1, [r0, #24]
    caca:	e7f8      	b.n	cabe <_system_pinmux_config+0x92>
			port->DIRSET.reg = pin_mask;
    cacc:	6081      	str	r1, [r0, #8]
}
    cace:	e7fa      	b.n	cac6 <_system_pinmux_config+0x9a>
    cad0:	fffbffff 	.word	0xfffbffff

0000cad4 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    cad4:	b510      	push	{r4, lr}
    cad6:	000a      	movs	r2, r1
	if (port_index < PORT_INST_NUM) {
    cad8:	09c1      	lsrs	r1, r0, #7
		return NULL;
    cada:	2300      	movs	r3, #0
	if (port_index < PORT_INST_NUM) {
    cadc:	2900      	cmp	r1, #0
    cade:	d104      	bne.n	caea <system_pinmux_pin_set_config+0x16>
		return &(ports[port_index]->Group[group_index]);
    cae0:	0943      	lsrs	r3, r0, #5
    cae2:	01db      	lsls	r3, r3, #7
    cae4:	4905      	ldr	r1, [pc, #20]	; (cafc <system_pinmux_pin_set_config+0x28>)
    cae6:	468c      	mov	ip, r1
    cae8:	4463      	add	r3, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    caea:	241f      	movs	r4, #31
    caec:	4020      	ands	r0, r4
    caee:	2101      	movs	r1, #1
    caf0:	4081      	lsls	r1, r0

	_system_pinmux_config(port, pin_mask, config);
    caf2:	0018      	movs	r0, r3
    caf4:	4b02      	ldr	r3, [pc, #8]	; (cb00 <system_pinmux_pin_set_config+0x2c>)
    caf6:	4798      	blx	r3
}
    caf8:	bd10      	pop	{r4, pc}
    cafa:	46c0      	nop			; (mov r8, r8)
    cafc:	41004400 	.word	0x41004400
    cb00:	0000ca2d 	.word	0x0000ca2d

0000cb04 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    cb04:	4770      	bx	lr
	...

0000cb08 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    cb08:	b510      	push	{r4, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    cb0a:	4b05      	ldr	r3, [pc, #20]	; (cb20 <system_init+0x18>)
    cb0c:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    cb0e:	4b05      	ldr	r3, [pc, #20]	; (cb24 <system_init+0x1c>)
    cb10:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    cb12:	4b05      	ldr	r3, [pc, #20]	; (cb28 <system_init+0x20>)
    cb14:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    cb16:	4b05      	ldr	r3, [pc, #20]	; (cb2c <system_init+0x24>)
    cb18:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    cb1a:	4b05      	ldr	r3, [pc, #20]	; (cb30 <system_init+0x28>)
    cb1c:	4798      	blx	r3
}
    cb1e:	bd10      	pop	{r4, pc}
    cb20:	0000c651 	.word	0x0000c651
    cb24:	0000b115 	.word	0x0000b115
    cb28:	0000cb05 	.word	0x0000cb05
    cb2c:	0000cb05 	.word	0x0000cb05
    cb30:	0000cb05 	.word	0x0000cb05

0000cb34 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    cb34:	e7fe      	b.n	cb34 <Dummy_Handler>
	...

0000cb38 <Reset_Handler>:
{
    cb38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
    cb3a:	4a2a      	ldr	r2, [pc, #168]	; (cbe4 <Reset_Handler+0xac>)
    cb3c:	4b2a      	ldr	r3, [pc, #168]	; (cbe8 <Reset_Handler+0xb0>)
    cb3e:	429a      	cmp	r2, r3
    cb40:	d011      	beq.n	cb66 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
    cb42:	001a      	movs	r2, r3
    cb44:	4b29      	ldr	r3, [pc, #164]	; (cbec <Reset_Handler+0xb4>)
    cb46:	429a      	cmp	r2, r3
    cb48:	d20d      	bcs.n	cb66 <Reset_Handler+0x2e>
    cb4a:	4a29      	ldr	r2, [pc, #164]	; (cbf0 <Reset_Handler+0xb8>)
    cb4c:	3303      	adds	r3, #3
    cb4e:	1a9b      	subs	r3, r3, r2
    cb50:	089b      	lsrs	r3, r3, #2
    cb52:	3301      	adds	r3, #1
    cb54:	009b      	lsls	r3, r3, #2
    cb56:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    cb58:	4823      	ldr	r0, [pc, #140]	; (cbe8 <Reset_Handler+0xb0>)
    cb5a:	4922      	ldr	r1, [pc, #136]	; (cbe4 <Reset_Handler+0xac>)
    cb5c:	588c      	ldr	r4, [r1, r2]
    cb5e:	5084      	str	r4, [r0, r2]
    cb60:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
    cb62:	429a      	cmp	r2, r3
    cb64:	d1fa      	bne.n	cb5c <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
    cb66:	4a23      	ldr	r2, [pc, #140]	; (cbf4 <Reset_Handler+0xbc>)
    cb68:	4b23      	ldr	r3, [pc, #140]	; (cbf8 <Reset_Handler+0xc0>)
    cb6a:	429a      	cmp	r2, r3
    cb6c:	d20a      	bcs.n	cb84 <Reset_Handler+0x4c>
    cb6e:	43d3      	mvns	r3, r2
    cb70:	4921      	ldr	r1, [pc, #132]	; (cbf8 <Reset_Handler+0xc0>)
    cb72:	185b      	adds	r3, r3, r1
    cb74:	2103      	movs	r1, #3
    cb76:	438b      	bics	r3, r1
    cb78:	3304      	adds	r3, #4
    cb7a:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
    cb7c:	2100      	movs	r1, #0
    cb7e:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
    cb80:	4293      	cmp	r3, r2
    cb82:	d1fc      	bne.n	cb7e <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    cb84:	4a1d      	ldr	r2, [pc, #116]	; (cbfc <Reset_Handler+0xc4>)
    cb86:	21ff      	movs	r1, #255	; 0xff
    cb88:	4b1d      	ldr	r3, [pc, #116]	; (cc00 <Reset_Handler+0xc8>)
    cb8a:	438b      	bics	r3, r1
    cb8c:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    cb8e:	39fd      	subs	r1, #253	; 0xfd
    cb90:	2390      	movs	r3, #144	; 0x90
    cb92:	005b      	lsls	r3, r3, #1
    cb94:	4a1b      	ldr	r2, [pc, #108]	; (cc04 <Reset_Handler+0xcc>)
    cb96:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    cb98:	4a1b      	ldr	r2, [pc, #108]	; (cc08 <Reset_Handler+0xd0>)
    cb9a:	78d3      	ldrb	r3, [r2, #3]
    cb9c:	2503      	movs	r5, #3
    cb9e:	43ab      	bics	r3, r5
    cba0:	2402      	movs	r4, #2
    cba2:	4323      	orrs	r3, r4
    cba4:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    cba6:	78d3      	ldrb	r3, [r2, #3]
    cba8:	270c      	movs	r7, #12
    cbaa:	43bb      	bics	r3, r7
    cbac:	2608      	movs	r6, #8
    cbae:	4333      	orrs	r3, r6
    cbb0:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    cbb2:	4b16      	ldr	r3, [pc, #88]	; (cc0c <Reset_Handler+0xd4>)
    cbb4:	7b98      	ldrb	r0, [r3, #14]
    cbb6:	2230      	movs	r2, #48	; 0x30
    cbb8:	4390      	bics	r0, r2
    cbba:	2220      	movs	r2, #32
    cbbc:	4310      	orrs	r0, r2
    cbbe:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    cbc0:	7b99      	ldrb	r1, [r3, #14]
    cbc2:	43b9      	bics	r1, r7
    cbc4:	4331      	orrs	r1, r6
    cbc6:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    cbc8:	7b9a      	ldrb	r2, [r3, #14]
    cbca:	43aa      	bics	r2, r5
    cbcc:	4322      	orrs	r2, r4
    cbce:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
    cbd0:	4a0f      	ldr	r2, [pc, #60]	; (cc10 <Reset_Handler+0xd8>)
    cbd2:	6853      	ldr	r3, [r2, #4]
    cbd4:	2180      	movs	r1, #128	; 0x80
    cbd6:	430b      	orrs	r3, r1
    cbd8:	6053      	str	r3, [r2, #4]
        __libc_init_array();
    cbda:	4b0e      	ldr	r3, [pc, #56]	; (cc14 <Reset_Handler+0xdc>)
    cbdc:	4798      	blx	r3
        main();
    cbde:	4b0e      	ldr	r3, [pc, #56]	; (cc18 <Reset_Handler+0xe0>)
    cbe0:	4798      	blx	r3
    cbe2:	e7fe      	b.n	cbe2 <Reset_Handler+0xaa>
    cbe4:	0000d2c8 	.word	0x0000d2c8
    cbe8:	20000000 	.word	0x20000000
    cbec:	20000074 	.word	0x20000074
    cbf0:	20000004 	.word	0x20000004
    cbf4:	20000074 	.word	0x20000074
    cbf8:	200005a4 	.word	0x200005a4
    cbfc:	e000ed00 	.word	0xe000ed00
    cc00:	0000b000 	.word	0x0000b000
    cc04:	41007000 	.word	0x41007000
    cc08:	41005000 	.word	0x41005000
    cc0c:	41004800 	.word	0x41004800
    cc10:	41004000 	.word	0x41004000
    cc14:	0000d0b9 	.word	0x0000d0b9
    cc18:	0000cc69 	.word	0x0000cc69

0000cc1c <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
    cc1c:	0003      	movs	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    cc1e:	4a06      	ldr	r2, [pc, #24]	; (cc38 <_sbrk+0x1c>)
    cc20:	6812      	ldr	r2, [r2, #0]
    cc22:	2a00      	cmp	r2, #0
    cc24:	d004      	beq.n	cc30 <_sbrk+0x14>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
    cc26:	4a04      	ldr	r2, [pc, #16]	; (cc38 <_sbrk+0x1c>)
    cc28:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    cc2a:	18c3      	adds	r3, r0, r3
    cc2c:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
}
    cc2e:	4770      	bx	lr
		heap = (unsigned char *)&_end;
    cc30:	4902      	ldr	r1, [pc, #8]	; (cc3c <_sbrk+0x20>)
    cc32:	4a01      	ldr	r2, [pc, #4]	; (cc38 <_sbrk+0x1c>)
    cc34:	6011      	str	r1, [r2, #0]
    cc36:	e7f6      	b.n	cc26 <_sbrk+0xa>
    cc38:	20000134 	.word	0x20000134
    cc3c:	200025a8 	.word	0x200025a8

0000cc40 <configure_port_pins>:

//! Structure for UART module connected to EDBG (used for unit test output)
struct usart_module cdc_uart_module;

void configure_port_pins(void)
{
    cc40:	b570      	push	{r4, r5, r6, lr}
    cc42:	b082      	sub	sp, #8
	config->direction  = PORT_PIN_DIR_INPUT;
    cc44:	ac01      	add	r4, sp, #4
    cc46:	2300      	movs	r3, #0
    cc48:	7023      	strb	r3, [r4, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    cc4a:	2601      	movs	r6, #1
    cc4c:	7066      	strb	r6, [r4, #1]
	config->powersave  = false;
    cc4e:	70a3      	strb	r3, [r4, #2]
	struct port_config config_port_pin;
	port_get_config_defaults(&config_port_pin);
	config_port_pin.direction  = PORT_PIN_DIR_INPUT;
	config_port_pin.input_pull = PORT_PIN_PULL_UP;
	port_pin_set_config(PIN_PB23, &config_port_pin);
    cc50:	0021      	movs	r1, r4
    cc52:	2037      	movs	r0, #55	; 0x37
    cc54:	4d03      	ldr	r5, [pc, #12]	; (cc64 <configure_port_pins+0x24>)
    cc56:	47a8      	blx	r5
	config_port_pin.direction = PORT_PIN_DIR_OUTPUT;
    cc58:	7026      	strb	r6, [r4, #0]
	port_pin_set_config(PIN_PA23, &config_port_pin);
    cc5a:	0021      	movs	r1, r4
    cc5c:	2017      	movs	r0, #23
    cc5e:	47a8      	blx	r5
}
    cc60:	b002      	add	sp, #8
    cc62:	bd70      	pop	{r4, r5, r6, pc}
    cc64:	0000b5b9 	.word	0x0000b5b9

0000cc68 <main>:
 * \brief Application entry point.
 *
 * \return Unused (ANSI-C compatibility).
 */
int main(void)
{
    cc68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    cc6a:	46de      	mov	lr, fp
    cc6c:	4657      	mov	r7, sl
    cc6e:	464e      	mov	r6, r9
    cc70:	4645      	mov	r5, r8
    cc72:	b5e0      	push	{r5, r6, r7, lr}
	FRESULT res;
	FATFS fs;
	FIL file_object;

	//INITIALIZE SYSTEM PERIPHERALS
	system_init();
    cc74:	4b21      	ldr	r3, [pc, #132]	; (ccfc <main+0x94>)
    cc76:	4798      	blx	r3
	delay_init();
    cc78:	4b21      	ldr	r3, [pc, #132]	; (cd00 <main+0x98>)
    cc7a:	4798      	blx	r3
	InitializeSerialConsole();
    cc7c:	4b21      	ldr	r3, [pc, #132]	; (cd04 <main+0x9c>)
    cc7e:	4798      	blx	r3
	cpu_irq_enable();
    cc80:	4c21      	ldr	r4, [pc, #132]	; (cd08 <main+0xa0>)
    cc82:	2501      	movs	r5, #1
    cc84:	7025      	strb	r5, [r4, #0]
    cc86:	f3bf 8f5f 	dmb	sy
    cc8a:	b662      	cpsie	i
	system_interrupt_enable_global();
	/* Initialize SD MMC stack */
	sd_mmc_init();
    cc8c:	4b1f      	ldr	r3, [pc, #124]	; (cd0c <main+0xa4>)
    cc8e:	4798      	blx	r3
	configure_port_pins();
    cc90:	4b1f      	ldr	r3, [pc, #124]	; (cd10 <main+0xa8>)
    cc92:	4798      	blx	r3
	irq_initialize_vectors();
	cpu_irq_enable();
    cc94:	7025      	strb	r5, [r4, #0]
    cc96:	f3bf 8f5f 	dmb	sy
    cc9a:	b662      	cpsie	i

	SerialConsoleWriteString("ESE516 - MAIN APPLICATION running!\r\n\r\n");	//Order to add string to TX Buffer
    cc9c:	481d      	ldr	r0, [pc, #116]	; (cd14 <main+0xac>)
    cc9e:	4b1e      	ldr	r3, [pc, #120]	; (cd18 <main+0xb0>)
    cca0:	4798      	blx	r3
	
	while(1){
		port_pin_set_output_level(PIN_PA23, 1);
		delay_ms(50);
    cca2:	4b1e      	ldr	r3, [pc, #120]	; (cd1c <main+0xb4>)
    cca4:	469b      	mov	fp, r3
    cca6:	4b1e      	ldr	r3, [pc, #120]	; (cd20 <main+0xb8>)
    cca8:	469a      	mov	sl, r3
		port_base->OUTSET.reg = pin_mask;
    ccaa:	4b1e      	ldr	r3, [pc, #120]	; (cd24 <main+0xbc>)
    ccac:	4698      	mov	r8, r3
    ccae:	2380      	movs	r3, #128	; 0x80
    ccb0:	041b      	lsls	r3, r3, #16
    ccb2:	4699      	mov	r9, r3
    ccb4:	4643      	mov	r3, r8
    ccb6:	464a      	mov	r2, r9
    ccb8:	619a      	str	r2, [r3, #24]
    ccba:	2000      	movs	r0, #0
    ccbc:	47d8      	blx	fp
    ccbe:	2232      	movs	r2, #50	; 0x32
    ccc0:	2300      	movs	r3, #0
    ccc2:	2100      	movs	r1, #0
    ccc4:	47d0      	blx	sl
    ccc6:	4e18      	ldr	r6, [pc, #96]	; (cd28 <main+0xc0>)
    ccc8:	2700      	movs	r7, #0
    ccca:	1980      	adds	r0, r0, r6
    cccc:	4179      	adcs	r1, r7
    ccce:	4d17      	ldr	r5, [pc, #92]	; (cd2c <main+0xc4>)
    ccd0:	4a17      	ldr	r2, [pc, #92]	; (cd30 <main+0xc8>)
    ccd2:	2300      	movs	r3, #0
    ccd4:	47a8      	blx	r5
    ccd6:	4c17      	ldr	r4, [pc, #92]	; (cd34 <main+0xcc>)
    ccd8:	47a0      	blx	r4
	} else {
		port_base->OUTCLR.reg = pin_mask;
    ccda:	4643      	mov	r3, r8
    ccdc:	464a      	mov	r2, r9
    ccde:	615a      	str	r2, [r3, #20]
		port_pin_set_output_level(PIN_PA23, 0);
		delay_ms(50);
    cce0:	2000      	movs	r0, #0
    cce2:	47d8      	blx	fp
    cce4:	2232      	movs	r2, #50	; 0x32
    cce6:	2300      	movs	r3, #0
    cce8:	2100      	movs	r1, #0
    ccea:	47d0      	blx	sl
    ccec:	1980      	adds	r0, r0, r6
    ccee:	4179      	adcs	r1, r7
    ccf0:	4a0f      	ldr	r2, [pc, #60]	; (cd30 <main+0xc8>)
    ccf2:	2300      	movs	r3, #0
    ccf4:	47a8      	blx	r5
    ccf6:	47a0      	blx	r4
    ccf8:	e7d7      	b.n	ccaa <main+0x42>
    ccfa:	46c0      	nop			; (mov r8, r8)
    ccfc:	0000cb09 	.word	0x0000cb09
    cd00:	0000b545 	.word	0x0000b545
    cd04:	0000b235 	.word	0x0000b235
    cd08:	2000000d 	.word	0x2000000d
    cd0c:	0000b425 	.word	0x0000b425
    cd10:	0000cc41 	.word	0x0000cc41
    cd14:	0000d278 	.word	0x0000d278
    cd18:	0000b35d 	.word	0x0000b35d
    cd1c:	0000c8c5 	.word	0x0000c8c5
    cd20:	0000ce91 	.word	0x0000ce91
    cd24:	41004400 	.word	0x41004400
    cd28:	00001b57 	.word	0x00001b57
    cd2c:	0000ce51 	.word	0x0000ce51
    cd30:	00001b58 	.word	0x00001b58
    cd34:	20000001 	.word	0x20000001

0000cd38 <__udivsi3>:
    cd38:	2200      	movs	r2, #0
    cd3a:	0843      	lsrs	r3, r0, #1
    cd3c:	428b      	cmp	r3, r1
    cd3e:	d374      	bcc.n	ce2a <__udivsi3+0xf2>
    cd40:	0903      	lsrs	r3, r0, #4
    cd42:	428b      	cmp	r3, r1
    cd44:	d35f      	bcc.n	ce06 <__udivsi3+0xce>
    cd46:	0a03      	lsrs	r3, r0, #8
    cd48:	428b      	cmp	r3, r1
    cd4a:	d344      	bcc.n	cdd6 <__udivsi3+0x9e>
    cd4c:	0b03      	lsrs	r3, r0, #12
    cd4e:	428b      	cmp	r3, r1
    cd50:	d328      	bcc.n	cda4 <__udivsi3+0x6c>
    cd52:	0c03      	lsrs	r3, r0, #16
    cd54:	428b      	cmp	r3, r1
    cd56:	d30d      	bcc.n	cd74 <__udivsi3+0x3c>
    cd58:	22ff      	movs	r2, #255	; 0xff
    cd5a:	0209      	lsls	r1, r1, #8
    cd5c:	ba12      	rev	r2, r2
    cd5e:	0c03      	lsrs	r3, r0, #16
    cd60:	428b      	cmp	r3, r1
    cd62:	d302      	bcc.n	cd6a <__udivsi3+0x32>
    cd64:	1212      	asrs	r2, r2, #8
    cd66:	0209      	lsls	r1, r1, #8
    cd68:	d065      	beq.n	ce36 <__udivsi3+0xfe>
    cd6a:	0b03      	lsrs	r3, r0, #12
    cd6c:	428b      	cmp	r3, r1
    cd6e:	d319      	bcc.n	cda4 <__udivsi3+0x6c>
    cd70:	e000      	b.n	cd74 <__udivsi3+0x3c>
    cd72:	0a09      	lsrs	r1, r1, #8
    cd74:	0bc3      	lsrs	r3, r0, #15
    cd76:	428b      	cmp	r3, r1
    cd78:	d301      	bcc.n	cd7e <__udivsi3+0x46>
    cd7a:	03cb      	lsls	r3, r1, #15
    cd7c:	1ac0      	subs	r0, r0, r3
    cd7e:	4152      	adcs	r2, r2
    cd80:	0b83      	lsrs	r3, r0, #14
    cd82:	428b      	cmp	r3, r1
    cd84:	d301      	bcc.n	cd8a <__udivsi3+0x52>
    cd86:	038b      	lsls	r3, r1, #14
    cd88:	1ac0      	subs	r0, r0, r3
    cd8a:	4152      	adcs	r2, r2
    cd8c:	0b43      	lsrs	r3, r0, #13
    cd8e:	428b      	cmp	r3, r1
    cd90:	d301      	bcc.n	cd96 <__udivsi3+0x5e>
    cd92:	034b      	lsls	r3, r1, #13
    cd94:	1ac0      	subs	r0, r0, r3
    cd96:	4152      	adcs	r2, r2
    cd98:	0b03      	lsrs	r3, r0, #12
    cd9a:	428b      	cmp	r3, r1
    cd9c:	d301      	bcc.n	cda2 <__udivsi3+0x6a>
    cd9e:	030b      	lsls	r3, r1, #12
    cda0:	1ac0      	subs	r0, r0, r3
    cda2:	4152      	adcs	r2, r2
    cda4:	0ac3      	lsrs	r3, r0, #11
    cda6:	428b      	cmp	r3, r1
    cda8:	d301      	bcc.n	cdae <__udivsi3+0x76>
    cdaa:	02cb      	lsls	r3, r1, #11
    cdac:	1ac0      	subs	r0, r0, r3
    cdae:	4152      	adcs	r2, r2
    cdb0:	0a83      	lsrs	r3, r0, #10
    cdb2:	428b      	cmp	r3, r1
    cdb4:	d301      	bcc.n	cdba <__udivsi3+0x82>
    cdb6:	028b      	lsls	r3, r1, #10
    cdb8:	1ac0      	subs	r0, r0, r3
    cdba:	4152      	adcs	r2, r2
    cdbc:	0a43      	lsrs	r3, r0, #9
    cdbe:	428b      	cmp	r3, r1
    cdc0:	d301      	bcc.n	cdc6 <__udivsi3+0x8e>
    cdc2:	024b      	lsls	r3, r1, #9
    cdc4:	1ac0      	subs	r0, r0, r3
    cdc6:	4152      	adcs	r2, r2
    cdc8:	0a03      	lsrs	r3, r0, #8
    cdca:	428b      	cmp	r3, r1
    cdcc:	d301      	bcc.n	cdd2 <__udivsi3+0x9a>
    cdce:	020b      	lsls	r3, r1, #8
    cdd0:	1ac0      	subs	r0, r0, r3
    cdd2:	4152      	adcs	r2, r2
    cdd4:	d2cd      	bcs.n	cd72 <__udivsi3+0x3a>
    cdd6:	09c3      	lsrs	r3, r0, #7
    cdd8:	428b      	cmp	r3, r1
    cdda:	d301      	bcc.n	cde0 <__udivsi3+0xa8>
    cddc:	01cb      	lsls	r3, r1, #7
    cdde:	1ac0      	subs	r0, r0, r3
    cde0:	4152      	adcs	r2, r2
    cde2:	0983      	lsrs	r3, r0, #6
    cde4:	428b      	cmp	r3, r1
    cde6:	d301      	bcc.n	cdec <__udivsi3+0xb4>
    cde8:	018b      	lsls	r3, r1, #6
    cdea:	1ac0      	subs	r0, r0, r3
    cdec:	4152      	adcs	r2, r2
    cdee:	0943      	lsrs	r3, r0, #5
    cdf0:	428b      	cmp	r3, r1
    cdf2:	d301      	bcc.n	cdf8 <__udivsi3+0xc0>
    cdf4:	014b      	lsls	r3, r1, #5
    cdf6:	1ac0      	subs	r0, r0, r3
    cdf8:	4152      	adcs	r2, r2
    cdfa:	0903      	lsrs	r3, r0, #4
    cdfc:	428b      	cmp	r3, r1
    cdfe:	d301      	bcc.n	ce04 <__udivsi3+0xcc>
    ce00:	010b      	lsls	r3, r1, #4
    ce02:	1ac0      	subs	r0, r0, r3
    ce04:	4152      	adcs	r2, r2
    ce06:	08c3      	lsrs	r3, r0, #3
    ce08:	428b      	cmp	r3, r1
    ce0a:	d301      	bcc.n	ce10 <__udivsi3+0xd8>
    ce0c:	00cb      	lsls	r3, r1, #3
    ce0e:	1ac0      	subs	r0, r0, r3
    ce10:	4152      	adcs	r2, r2
    ce12:	0883      	lsrs	r3, r0, #2
    ce14:	428b      	cmp	r3, r1
    ce16:	d301      	bcc.n	ce1c <__udivsi3+0xe4>
    ce18:	008b      	lsls	r3, r1, #2
    ce1a:	1ac0      	subs	r0, r0, r3
    ce1c:	4152      	adcs	r2, r2
    ce1e:	0843      	lsrs	r3, r0, #1
    ce20:	428b      	cmp	r3, r1
    ce22:	d301      	bcc.n	ce28 <__udivsi3+0xf0>
    ce24:	004b      	lsls	r3, r1, #1
    ce26:	1ac0      	subs	r0, r0, r3
    ce28:	4152      	adcs	r2, r2
    ce2a:	1a41      	subs	r1, r0, r1
    ce2c:	d200      	bcs.n	ce30 <__udivsi3+0xf8>
    ce2e:	4601      	mov	r1, r0
    ce30:	4152      	adcs	r2, r2
    ce32:	4610      	mov	r0, r2
    ce34:	4770      	bx	lr
    ce36:	e7ff      	b.n	ce38 <__udivsi3+0x100>
    ce38:	b501      	push	{r0, lr}
    ce3a:	2000      	movs	r0, #0
    ce3c:	f000 f806 	bl	ce4c <__aeabi_idiv0>
    ce40:	bd02      	pop	{r1, pc}
    ce42:	46c0      	nop			; (mov r8, r8)

0000ce44 <__aeabi_uidivmod>:
    ce44:	2900      	cmp	r1, #0
    ce46:	d0f7      	beq.n	ce38 <__udivsi3+0x100>
    ce48:	e776      	b.n	cd38 <__udivsi3>
    ce4a:	4770      	bx	lr

0000ce4c <__aeabi_idiv0>:
    ce4c:	4770      	bx	lr
    ce4e:	46c0      	nop			; (mov r8, r8)

0000ce50 <__aeabi_uldivmod>:
    ce50:	2b00      	cmp	r3, #0
    ce52:	d111      	bne.n	ce78 <__aeabi_uldivmod+0x28>
    ce54:	2a00      	cmp	r2, #0
    ce56:	d10f      	bne.n	ce78 <__aeabi_uldivmod+0x28>
    ce58:	2900      	cmp	r1, #0
    ce5a:	d100      	bne.n	ce5e <__aeabi_uldivmod+0xe>
    ce5c:	2800      	cmp	r0, #0
    ce5e:	d002      	beq.n	ce66 <__aeabi_uldivmod+0x16>
    ce60:	2100      	movs	r1, #0
    ce62:	43c9      	mvns	r1, r1
    ce64:	1c08      	adds	r0, r1, #0
    ce66:	b407      	push	{r0, r1, r2}
    ce68:	4802      	ldr	r0, [pc, #8]	; (ce74 <__aeabi_uldivmod+0x24>)
    ce6a:	a102      	add	r1, pc, #8	; (adr r1, ce74 <__aeabi_uldivmod+0x24>)
    ce6c:	1840      	adds	r0, r0, r1
    ce6e:	9002      	str	r0, [sp, #8]
    ce70:	bd03      	pop	{r0, r1, pc}
    ce72:	46c0      	nop			; (mov r8, r8)
    ce74:	ffffffd9 	.word	0xffffffd9
    ce78:	b403      	push	{r0, r1}
    ce7a:	4668      	mov	r0, sp
    ce7c:	b501      	push	{r0, lr}
    ce7e:	9802      	ldr	r0, [sp, #8]
    ce80:	f000 f830 	bl	cee4 <__udivmoddi4>
    ce84:	9b01      	ldr	r3, [sp, #4]
    ce86:	469e      	mov	lr, r3
    ce88:	b002      	add	sp, #8
    ce8a:	bc0c      	pop	{r2, r3}
    ce8c:	4770      	bx	lr
    ce8e:	46c0      	nop			; (mov r8, r8)

0000ce90 <__aeabi_lmul>:
    ce90:	b5f0      	push	{r4, r5, r6, r7, lr}
    ce92:	46ce      	mov	lr, r9
    ce94:	4647      	mov	r7, r8
    ce96:	0415      	lsls	r5, r2, #16
    ce98:	0c2d      	lsrs	r5, r5, #16
    ce9a:	002e      	movs	r6, r5
    ce9c:	b580      	push	{r7, lr}
    ce9e:	0407      	lsls	r7, r0, #16
    cea0:	0c14      	lsrs	r4, r2, #16
    cea2:	0c3f      	lsrs	r7, r7, #16
    cea4:	4699      	mov	r9, r3
    cea6:	0c03      	lsrs	r3, r0, #16
    cea8:	437e      	muls	r6, r7
    ceaa:	435d      	muls	r5, r3
    ceac:	4367      	muls	r7, r4
    ceae:	4363      	muls	r3, r4
    ceb0:	197f      	adds	r7, r7, r5
    ceb2:	0c34      	lsrs	r4, r6, #16
    ceb4:	19e4      	adds	r4, r4, r7
    ceb6:	469c      	mov	ip, r3
    ceb8:	42a5      	cmp	r5, r4
    ceba:	d903      	bls.n	cec4 <__aeabi_lmul+0x34>
    cebc:	2380      	movs	r3, #128	; 0x80
    cebe:	025b      	lsls	r3, r3, #9
    cec0:	4698      	mov	r8, r3
    cec2:	44c4      	add	ip, r8
    cec4:	464b      	mov	r3, r9
    cec6:	4351      	muls	r1, r2
    cec8:	4343      	muls	r3, r0
    ceca:	0436      	lsls	r6, r6, #16
    cecc:	0c36      	lsrs	r6, r6, #16
    cece:	0c25      	lsrs	r5, r4, #16
    ced0:	0424      	lsls	r4, r4, #16
    ced2:	4465      	add	r5, ip
    ced4:	19a4      	adds	r4, r4, r6
    ced6:	1859      	adds	r1, r3, r1
    ced8:	1949      	adds	r1, r1, r5
    ceda:	0020      	movs	r0, r4
    cedc:	bc0c      	pop	{r2, r3}
    cede:	4690      	mov	r8, r2
    cee0:	4699      	mov	r9, r3
    cee2:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000cee4 <__udivmoddi4>:
    cee4:	b5f0      	push	{r4, r5, r6, r7, lr}
    cee6:	4657      	mov	r7, sl
    cee8:	464e      	mov	r6, r9
    ceea:	4645      	mov	r5, r8
    ceec:	46de      	mov	lr, fp
    ceee:	b5e0      	push	{r5, r6, r7, lr}
    cef0:	0004      	movs	r4, r0
    cef2:	b083      	sub	sp, #12
    cef4:	000d      	movs	r5, r1
    cef6:	4692      	mov	sl, r2
    cef8:	4699      	mov	r9, r3
    cefa:	428b      	cmp	r3, r1
    cefc:	d82f      	bhi.n	cf5e <__udivmoddi4+0x7a>
    cefe:	d02c      	beq.n	cf5a <__udivmoddi4+0x76>
    cf00:	4649      	mov	r1, r9
    cf02:	4650      	mov	r0, sl
    cf04:	f000 f8ae 	bl	d064 <__clzdi2>
    cf08:	0029      	movs	r1, r5
    cf0a:	0006      	movs	r6, r0
    cf0c:	0020      	movs	r0, r4
    cf0e:	f000 f8a9 	bl	d064 <__clzdi2>
    cf12:	1a33      	subs	r3, r6, r0
    cf14:	4698      	mov	r8, r3
    cf16:	3b20      	subs	r3, #32
    cf18:	469b      	mov	fp, r3
    cf1a:	d500      	bpl.n	cf1e <__udivmoddi4+0x3a>
    cf1c:	e074      	b.n	d008 <__udivmoddi4+0x124>
    cf1e:	4653      	mov	r3, sl
    cf20:	465a      	mov	r2, fp
    cf22:	4093      	lsls	r3, r2
    cf24:	001f      	movs	r7, r3
    cf26:	4653      	mov	r3, sl
    cf28:	4642      	mov	r2, r8
    cf2a:	4093      	lsls	r3, r2
    cf2c:	001e      	movs	r6, r3
    cf2e:	42af      	cmp	r7, r5
    cf30:	d829      	bhi.n	cf86 <__udivmoddi4+0xa2>
    cf32:	d026      	beq.n	cf82 <__udivmoddi4+0x9e>
    cf34:	465b      	mov	r3, fp
    cf36:	1ba4      	subs	r4, r4, r6
    cf38:	41bd      	sbcs	r5, r7
    cf3a:	2b00      	cmp	r3, #0
    cf3c:	da00      	bge.n	cf40 <__udivmoddi4+0x5c>
    cf3e:	e079      	b.n	d034 <__udivmoddi4+0x150>
    cf40:	2200      	movs	r2, #0
    cf42:	2300      	movs	r3, #0
    cf44:	9200      	str	r2, [sp, #0]
    cf46:	9301      	str	r3, [sp, #4]
    cf48:	2301      	movs	r3, #1
    cf4a:	465a      	mov	r2, fp
    cf4c:	4093      	lsls	r3, r2
    cf4e:	9301      	str	r3, [sp, #4]
    cf50:	2301      	movs	r3, #1
    cf52:	4642      	mov	r2, r8
    cf54:	4093      	lsls	r3, r2
    cf56:	9300      	str	r3, [sp, #0]
    cf58:	e019      	b.n	cf8e <__udivmoddi4+0xaa>
    cf5a:	4282      	cmp	r2, r0
    cf5c:	d9d0      	bls.n	cf00 <__udivmoddi4+0x1c>
    cf5e:	2200      	movs	r2, #0
    cf60:	2300      	movs	r3, #0
    cf62:	9200      	str	r2, [sp, #0]
    cf64:	9301      	str	r3, [sp, #4]
    cf66:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    cf68:	2b00      	cmp	r3, #0
    cf6a:	d001      	beq.n	cf70 <__udivmoddi4+0x8c>
    cf6c:	601c      	str	r4, [r3, #0]
    cf6e:	605d      	str	r5, [r3, #4]
    cf70:	9800      	ldr	r0, [sp, #0]
    cf72:	9901      	ldr	r1, [sp, #4]
    cf74:	b003      	add	sp, #12
    cf76:	bc3c      	pop	{r2, r3, r4, r5}
    cf78:	4690      	mov	r8, r2
    cf7a:	4699      	mov	r9, r3
    cf7c:	46a2      	mov	sl, r4
    cf7e:	46ab      	mov	fp, r5
    cf80:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cf82:	42a3      	cmp	r3, r4
    cf84:	d9d6      	bls.n	cf34 <__udivmoddi4+0x50>
    cf86:	2200      	movs	r2, #0
    cf88:	2300      	movs	r3, #0
    cf8a:	9200      	str	r2, [sp, #0]
    cf8c:	9301      	str	r3, [sp, #4]
    cf8e:	4643      	mov	r3, r8
    cf90:	2b00      	cmp	r3, #0
    cf92:	d0e8      	beq.n	cf66 <__udivmoddi4+0x82>
    cf94:	07fb      	lsls	r3, r7, #31
    cf96:	0872      	lsrs	r2, r6, #1
    cf98:	431a      	orrs	r2, r3
    cf9a:	4646      	mov	r6, r8
    cf9c:	087b      	lsrs	r3, r7, #1
    cf9e:	e00e      	b.n	cfbe <__udivmoddi4+0xda>
    cfa0:	42ab      	cmp	r3, r5
    cfa2:	d101      	bne.n	cfa8 <__udivmoddi4+0xc4>
    cfa4:	42a2      	cmp	r2, r4
    cfa6:	d80c      	bhi.n	cfc2 <__udivmoddi4+0xde>
    cfa8:	1aa4      	subs	r4, r4, r2
    cfaa:	419d      	sbcs	r5, r3
    cfac:	2001      	movs	r0, #1
    cfae:	1924      	adds	r4, r4, r4
    cfb0:	416d      	adcs	r5, r5
    cfb2:	2100      	movs	r1, #0
    cfb4:	3e01      	subs	r6, #1
    cfb6:	1824      	adds	r4, r4, r0
    cfb8:	414d      	adcs	r5, r1
    cfba:	2e00      	cmp	r6, #0
    cfbc:	d006      	beq.n	cfcc <__udivmoddi4+0xe8>
    cfbe:	42ab      	cmp	r3, r5
    cfc0:	d9ee      	bls.n	cfa0 <__udivmoddi4+0xbc>
    cfc2:	3e01      	subs	r6, #1
    cfc4:	1924      	adds	r4, r4, r4
    cfc6:	416d      	adcs	r5, r5
    cfc8:	2e00      	cmp	r6, #0
    cfca:	d1f8      	bne.n	cfbe <__udivmoddi4+0xda>
    cfcc:	465b      	mov	r3, fp
    cfce:	9800      	ldr	r0, [sp, #0]
    cfd0:	9901      	ldr	r1, [sp, #4]
    cfd2:	1900      	adds	r0, r0, r4
    cfd4:	4169      	adcs	r1, r5
    cfd6:	2b00      	cmp	r3, #0
    cfd8:	db22      	blt.n	d020 <__udivmoddi4+0x13c>
    cfda:	002b      	movs	r3, r5
    cfdc:	465a      	mov	r2, fp
    cfde:	40d3      	lsrs	r3, r2
    cfe0:	002a      	movs	r2, r5
    cfe2:	4644      	mov	r4, r8
    cfe4:	40e2      	lsrs	r2, r4
    cfe6:	001c      	movs	r4, r3
    cfe8:	465b      	mov	r3, fp
    cfea:	0015      	movs	r5, r2
    cfec:	2b00      	cmp	r3, #0
    cfee:	db2c      	blt.n	d04a <__udivmoddi4+0x166>
    cff0:	0026      	movs	r6, r4
    cff2:	409e      	lsls	r6, r3
    cff4:	0033      	movs	r3, r6
    cff6:	0026      	movs	r6, r4
    cff8:	4647      	mov	r7, r8
    cffa:	40be      	lsls	r6, r7
    cffc:	0032      	movs	r2, r6
    cffe:	1a80      	subs	r0, r0, r2
    d000:	4199      	sbcs	r1, r3
    d002:	9000      	str	r0, [sp, #0]
    d004:	9101      	str	r1, [sp, #4]
    d006:	e7ae      	b.n	cf66 <__udivmoddi4+0x82>
    d008:	4642      	mov	r2, r8
    d00a:	2320      	movs	r3, #32
    d00c:	1a9b      	subs	r3, r3, r2
    d00e:	4652      	mov	r2, sl
    d010:	40da      	lsrs	r2, r3
    d012:	4641      	mov	r1, r8
    d014:	0013      	movs	r3, r2
    d016:	464a      	mov	r2, r9
    d018:	408a      	lsls	r2, r1
    d01a:	0017      	movs	r7, r2
    d01c:	431f      	orrs	r7, r3
    d01e:	e782      	b.n	cf26 <__udivmoddi4+0x42>
    d020:	4642      	mov	r2, r8
    d022:	2320      	movs	r3, #32
    d024:	1a9b      	subs	r3, r3, r2
    d026:	002a      	movs	r2, r5
    d028:	4646      	mov	r6, r8
    d02a:	409a      	lsls	r2, r3
    d02c:	0023      	movs	r3, r4
    d02e:	40f3      	lsrs	r3, r6
    d030:	4313      	orrs	r3, r2
    d032:	e7d5      	b.n	cfe0 <__udivmoddi4+0xfc>
    d034:	4642      	mov	r2, r8
    d036:	2320      	movs	r3, #32
    d038:	2100      	movs	r1, #0
    d03a:	1a9b      	subs	r3, r3, r2
    d03c:	2200      	movs	r2, #0
    d03e:	9100      	str	r1, [sp, #0]
    d040:	9201      	str	r2, [sp, #4]
    d042:	2201      	movs	r2, #1
    d044:	40da      	lsrs	r2, r3
    d046:	9201      	str	r2, [sp, #4]
    d048:	e782      	b.n	cf50 <__udivmoddi4+0x6c>
    d04a:	4642      	mov	r2, r8
    d04c:	2320      	movs	r3, #32
    d04e:	0026      	movs	r6, r4
    d050:	1a9b      	subs	r3, r3, r2
    d052:	40de      	lsrs	r6, r3
    d054:	002f      	movs	r7, r5
    d056:	46b4      	mov	ip, r6
    d058:	4097      	lsls	r7, r2
    d05a:	4666      	mov	r6, ip
    d05c:	003b      	movs	r3, r7
    d05e:	4333      	orrs	r3, r6
    d060:	e7c9      	b.n	cff6 <__udivmoddi4+0x112>
    d062:	46c0      	nop			; (mov r8, r8)

0000d064 <__clzdi2>:
    d064:	b510      	push	{r4, lr}
    d066:	2900      	cmp	r1, #0
    d068:	d103      	bne.n	d072 <__clzdi2+0xe>
    d06a:	f000 f807 	bl	d07c <__clzsi2>
    d06e:	3020      	adds	r0, #32
    d070:	e002      	b.n	d078 <__clzdi2+0x14>
    d072:	1c08      	adds	r0, r1, #0
    d074:	f000 f802 	bl	d07c <__clzsi2>
    d078:	bd10      	pop	{r4, pc}
    d07a:	46c0      	nop			; (mov r8, r8)

0000d07c <__clzsi2>:
    d07c:	211c      	movs	r1, #28
    d07e:	2301      	movs	r3, #1
    d080:	041b      	lsls	r3, r3, #16
    d082:	4298      	cmp	r0, r3
    d084:	d301      	bcc.n	d08a <__clzsi2+0xe>
    d086:	0c00      	lsrs	r0, r0, #16
    d088:	3910      	subs	r1, #16
    d08a:	0a1b      	lsrs	r3, r3, #8
    d08c:	4298      	cmp	r0, r3
    d08e:	d301      	bcc.n	d094 <__clzsi2+0x18>
    d090:	0a00      	lsrs	r0, r0, #8
    d092:	3908      	subs	r1, #8
    d094:	091b      	lsrs	r3, r3, #4
    d096:	4298      	cmp	r0, r3
    d098:	d301      	bcc.n	d09e <__clzsi2+0x22>
    d09a:	0900      	lsrs	r0, r0, #4
    d09c:	3904      	subs	r1, #4
    d09e:	a202      	add	r2, pc, #8	; (adr r2, d0a8 <__clzsi2+0x2c>)
    d0a0:	5c10      	ldrb	r0, [r2, r0]
    d0a2:	1840      	adds	r0, r0, r1
    d0a4:	4770      	bx	lr
    d0a6:	46c0      	nop			; (mov r8, r8)
    d0a8:	02020304 	.word	0x02020304
    d0ac:	01010101 	.word	0x01010101
	...

0000d0b8 <__libc_init_array>:
    d0b8:	b570      	push	{r4, r5, r6, lr}
    d0ba:	2600      	movs	r6, #0
    d0bc:	4d0c      	ldr	r5, [pc, #48]	; (d0f0 <__libc_init_array+0x38>)
    d0be:	4c0d      	ldr	r4, [pc, #52]	; (d0f4 <__libc_init_array+0x3c>)
    d0c0:	1b64      	subs	r4, r4, r5
    d0c2:	10a4      	asrs	r4, r4, #2
    d0c4:	42a6      	cmp	r6, r4
    d0c6:	d109      	bne.n	d0dc <__libc_init_array+0x24>
    d0c8:	2600      	movs	r6, #0
    d0ca:	f000 f8e9 	bl	d2a0 <_init>
    d0ce:	4d0a      	ldr	r5, [pc, #40]	; (d0f8 <__libc_init_array+0x40>)
    d0d0:	4c0a      	ldr	r4, [pc, #40]	; (d0fc <__libc_init_array+0x44>)
    d0d2:	1b64      	subs	r4, r4, r5
    d0d4:	10a4      	asrs	r4, r4, #2
    d0d6:	42a6      	cmp	r6, r4
    d0d8:	d105      	bne.n	d0e6 <__libc_init_array+0x2e>
    d0da:	bd70      	pop	{r4, r5, r6, pc}
    d0dc:	00b3      	lsls	r3, r6, #2
    d0de:	58eb      	ldr	r3, [r5, r3]
    d0e0:	4798      	blx	r3
    d0e2:	3601      	adds	r6, #1
    d0e4:	e7ee      	b.n	d0c4 <__libc_init_array+0xc>
    d0e6:	00b3      	lsls	r3, r6, #2
    d0e8:	58eb      	ldr	r3, [r5, r3]
    d0ea:	4798      	blx	r3
    d0ec:	3601      	adds	r6, #1
    d0ee:	e7f2      	b.n	d0d6 <__libc_init_array+0x1e>
    d0f0:	0000d2ac 	.word	0x0000d2ac
    d0f4:	0000d2ac 	.word	0x0000d2ac
    d0f8:	0000d2ac 	.word	0x0000d2ac
    d0fc:	0000d2b0 	.word	0x0000d2b0

0000d100 <malloc>:
    d100:	b510      	push	{r4, lr}
    d102:	4b03      	ldr	r3, [pc, #12]	; (d110 <malloc+0x10>)
    d104:	0001      	movs	r1, r0
    d106:	6818      	ldr	r0, [r3, #0]
    d108:	f000 f80c 	bl	d124 <_malloc_r>
    d10c:	bd10      	pop	{r4, pc}
    d10e:	46c0      	nop			; (mov r8, r8)
    d110:	20000010 	.word	0x20000010

0000d114 <memset>:
    d114:	0003      	movs	r3, r0
    d116:	1882      	adds	r2, r0, r2
    d118:	4293      	cmp	r3, r2
    d11a:	d100      	bne.n	d11e <memset+0xa>
    d11c:	4770      	bx	lr
    d11e:	7019      	strb	r1, [r3, #0]
    d120:	3301      	adds	r3, #1
    d122:	e7f9      	b.n	d118 <memset+0x4>

0000d124 <_malloc_r>:
    d124:	2303      	movs	r3, #3
    d126:	b570      	push	{r4, r5, r6, lr}
    d128:	1ccd      	adds	r5, r1, #3
    d12a:	439d      	bics	r5, r3
    d12c:	3508      	adds	r5, #8
    d12e:	0006      	movs	r6, r0
    d130:	2d0c      	cmp	r5, #12
    d132:	d21e      	bcs.n	d172 <_malloc_r+0x4e>
    d134:	250c      	movs	r5, #12
    d136:	42a9      	cmp	r1, r5
    d138:	d81d      	bhi.n	d176 <_malloc_r+0x52>
    d13a:	0030      	movs	r0, r6
    d13c:	f000 f869 	bl	d212 <__malloc_lock>
    d140:	4a25      	ldr	r2, [pc, #148]	; (d1d8 <_malloc_r+0xb4>)
    d142:	6814      	ldr	r4, [r2, #0]
    d144:	0021      	movs	r1, r4
    d146:	2900      	cmp	r1, #0
    d148:	d119      	bne.n	d17e <_malloc_r+0x5a>
    d14a:	4c24      	ldr	r4, [pc, #144]	; (d1dc <_malloc_r+0xb8>)
    d14c:	6823      	ldr	r3, [r4, #0]
    d14e:	2b00      	cmp	r3, #0
    d150:	d103      	bne.n	d15a <_malloc_r+0x36>
    d152:	0030      	movs	r0, r6
    d154:	f000 f844 	bl	d1e0 <_sbrk_r>
    d158:	6020      	str	r0, [r4, #0]
    d15a:	0029      	movs	r1, r5
    d15c:	0030      	movs	r0, r6
    d15e:	f000 f83f 	bl	d1e0 <_sbrk_r>
    d162:	1c43      	adds	r3, r0, #1
    d164:	d12c      	bne.n	d1c0 <_malloc_r+0x9c>
    d166:	230c      	movs	r3, #12
    d168:	0030      	movs	r0, r6
    d16a:	6033      	str	r3, [r6, #0]
    d16c:	f000 f852 	bl	d214 <__malloc_unlock>
    d170:	e003      	b.n	d17a <_malloc_r+0x56>
    d172:	2d00      	cmp	r5, #0
    d174:	dadf      	bge.n	d136 <_malloc_r+0x12>
    d176:	230c      	movs	r3, #12
    d178:	6033      	str	r3, [r6, #0]
    d17a:	2000      	movs	r0, #0
    d17c:	bd70      	pop	{r4, r5, r6, pc}
    d17e:	680b      	ldr	r3, [r1, #0]
    d180:	1b5b      	subs	r3, r3, r5
    d182:	d41a      	bmi.n	d1ba <_malloc_r+0x96>
    d184:	2b0b      	cmp	r3, #11
    d186:	d903      	bls.n	d190 <_malloc_r+0x6c>
    d188:	600b      	str	r3, [r1, #0]
    d18a:	18cc      	adds	r4, r1, r3
    d18c:	6025      	str	r5, [r4, #0]
    d18e:	e003      	b.n	d198 <_malloc_r+0x74>
    d190:	428c      	cmp	r4, r1
    d192:	d10e      	bne.n	d1b2 <_malloc_r+0x8e>
    d194:	6863      	ldr	r3, [r4, #4]
    d196:	6013      	str	r3, [r2, #0]
    d198:	0030      	movs	r0, r6
    d19a:	f000 f83b 	bl	d214 <__malloc_unlock>
    d19e:	0020      	movs	r0, r4
    d1a0:	2207      	movs	r2, #7
    d1a2:	300b      	adds	r0, #11
    d1a4:	1d23      	adds	r3, r4, #4
    d1a6:	4390      	bics	r0, r2
    d1a8:	1ac3      	subs	r3, r0, r3
    d1aa:	d0e7      	beq.n	d17c <_malloc_r+0x58>
    d1ac:	425a      	negs	r2, r3
    d1ae:	50e2      	str	r2, [r4, r3]
    d1b0:	e7e4      	b.n	d17c <_malloc_r+0x58>
    d1b2:	684b      	ldr	r3, [r1, #4]
    d1b4:	6063      	str	r3, [r4, #4]
    d1b6:	000c      	movs	r4, r1
    d1b8:	e7ee      	b.n	d198 <_malloc_r+0x74>
    d1ba:	000c      	movs	r4, r1
    d1bc:	6849      	ldr	r1, [r1, #4]
    d1be:	e7c2      	b.n	d146 <_malloc_r+0x22>
    d1c0:	2303      	movs	r3, #3
    d1c2:	1cc4      	adds	r4, r0, #3
    d1c4:	439c      	bics	r4, r3
    d1c6:	42a0      	cmp	r0, r4
    d1c8:	d0e0      	beq.n	d18c <_malloc_r+0x68>
    d1ca:	1a21      	subs	r1, r4, r0
    d1cc:	0030      	movs	r0, r6
    d1ce:	f000 f807 	bl	d1e0 <_sbrk_r>
    d1d2:	1c43      	adds	r3, r0, #1
    d1d4:	d1da      	bne.n	d18c <_malloc_r+0x68>
    d1d6:	e7c6      	b.n	d166 <_malloc_r+0x42>
    d1d8:	20000138 	.word	0x20000138
    d1dc:	2000013c 	.word	0x2000013c

0000d1e0 <_sbrk_r>:
    d1e0:	2300      	movs	r3, #0
    d1e2:	b570      	push	{r4, r5, r6, lr}
    d1e4:	4c06      	ldr	r4, [pc, #24]	; (d200 <_sbrk_r+0x20>)
    d1e6:	0005      	movs	r5, r0
    d1e8:	0008      	movs	r0, r1
    d1ea:	6023      	str	r3, [r4, #0]
    d1ec:	f7ff fd16 	bl	cc1c <_sbrk>
    d1f0:	1c43      	adds	r3, r0, #1
    d1f2:	d103      	bne.n	d1fc <_sbrk_r+0x1c>
    d1f4:	6823      	ldr	r3, [r4, #0]
    d1f6:	2b00      	cmp	r3, #0
    d1f8:	d000      	beq.n	d1fc <_sbrk_r+0x1c>
    d1fa:	602b      	str	r3, [r5, #0]
    d1fc:	bd70      	pop	{r4, r5, r6, pc}
    d1fe:	46c0      	nop			; (mov r8, r8)
    d200:	200005a0 	.word	0x200005a0

0000d204 <strlen>:
    d204:	2300      	movs	r3, #0
    d206:	5cc2      	ldrb	r2, [r0, r3]
    d208:	3301      	adds	r3, #1
    d20a:	2a00      	cmp	r2, #0
    d20c:	d1fb      	bne.n	d206 <strlen+0x2>
    d20e:	1e58      	subs	r0, r3, #1
    d210:	4770      	bx	lr

0000d212 <__malloc_lock>:
    d212:	4770      	bx	lr

0000d214 <__malloc_unlock>:
    d214:	4770      	bx	lr
    d216:	0000      	movs	r0, r0
    d218:	42000800 	.word	0x42000800
    d21c:	42000c00 	.word	0x42000c00
    d220:	42001000 	.word	0x42001000
    d224:	42001400 	.word	0x42001400
    d228:	42001800 	.word	0x42001800
    d22c:	42001c00 	.word	0x42001c00
    d230:	0000c3b2 	.word	0x0000c3b2
    d234:	0000c3ae 	.word	0x0000c3ae
    d238:	0000c3ae 	.word	0x0000c3ae
    d23c:	0000c414 	.word	0x0000c414
    d240:	0000c414 	.word	0x0000c414
    d244:	0000c3c6 	.word	0x0000c3c6
    d248:	0000c3b8 	.word	0x0000c3b8
    d24c:	0000c3cc 	.word	0x0000c3cc
    d250:	0000c402 	.word	0x0000c402
    d254:	0000c5d4 	.word	0x0000c5d4
    d258:	0000c5b4 	.word	0x0000c5b4
    d25c:	0000c5b4 	.word	0x0000c5b4
    d260:	0000c640 	.word	0x0000c640
    d264:	0000c5c6 	.word	0x0000c5c6
    d268:	0000c5e2 	.word	0x0000c5e2
    d26c:	0000c5b8 	.word	0x0000c5b8
    d270:	0000c5f0 	.word	0x0000c5f0
    d274:	0000c630 	.word	0x0000c630
    d278:	35455345 	.word	0x35455345
    d27c:	2d203631 	.word	0x2d203631
    d280:	49414d20 	.word	0x49414d20
    d284:	5041204e 	.word	0x5041204e
    d288:	43494c50 	.word	0x43494c50
    d28c:	4f495441 	.word	0x4f495441
    d290:	7572204e 	.word	0x7572204e
    d294:	6e696e6e 	.word	0x6e696e6e
    d298:	0a0d2167 	.word	0x0a0d2167
    d29c:	00000a0d 	.word	0x00000a0d

0000d2a0 <_init>:
    d2a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d2a2:	46c0      	nop			; (mov r8, r8)
    d2a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    d2a6:	bc08      	pop	{r3}
    d2a8:	469e      	mov	lr, r3
    d2aa:	4770      	bx	lr

0000d2ac <__init_array_start>:
    d2ac:	0000b0dd 	.word	0x0000b0dd

0000d2b0 <_fini>:
    d2b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d2b2:	46c0      	nop			; (mov r8, r8)
    d2b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    d2b6:	bc08      	pop	{r3}
    d2b8:	469e      	mov	lr, r3
    d2ba:	4770      	bx	lr

0000d2bc <__fini_array_start>:
    d2bc:	0000b0b5 	.word	0x0000b0b5

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	2800      	cmp	r0, #0
20000008:	d1fa      	bne.n	20000000 <portable_delay_cycles>
		"SUB r0, r0, #1 \n"
#endif
		"CMP r0, #0  \n"
		"BNE loop         "
	);
}
2000000a:	4770      	bx	lr

2000000c <ss_pins>:
2000000c:	0111                                             .

2000000d <g_interrupt_enabled>:
2000000d:	0001 1400                                        ...

20000010 <_impure_ptr>:
20000010:	0014 2000                                   ... 

20000014 <impure_data>:
	...
